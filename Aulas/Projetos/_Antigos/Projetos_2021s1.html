<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <style>
  /* fundo para o trecho de código */
  div.sourceCode { overflow-x: auto; background-color: rgb(245,245,245);}  /*rgb(250,250,250)*/
  body {font-family: "Lato", sans-serif;}
  
  /* Para dividir a pagina em duas colunas */
   .column {
    float: left;
    width:49%;
    justify-content: center;
    align-items: center;
  }
  
  /* Clear floats after the columns */
  .row:after {
    content: "";
    display: table;
    clear: both;
  }
  
  /* Inicio do menu tipo acordeon */
  .accordion{
    background-color: #eee;
    color: #444;
    cursor: pointer;
    padding: 18px;
    width: 100%;
    border: none;
    text-align: left;
    outline: none;
    font-size: 15px;
    transition: 0.4s;
    font-weight: bold;
  }
  .active, .accordion:hover {
    background-color: #a4b8b6;
  }
  .panel {
    /*Versao anterior do accordion usa  max-height: 0 para fazer a transition e nao aceita aninhamento de acordeon*/
    padding: 0 10px;
    background-color: #f9f9f9;
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.2s ease-out;
    margin-left: 0%;
  }
  .panel p {
    margin-left: 1%;
  }
  /*Inicio do Acordeon Aninhado*/
  button.accordionNested{
    background-color: #eee;
    color: #444;
    cursor: pointer;
    padding: 18px;
    width: 100%;
    border: none;
    text-align: left;
    outline: none;
    font-size: 15px;
    font-weight: bold;
  }
  .activeNested, .accordionNested:hover {
    background-color: #a4b8b6;
  }
  .panelNested {
    /*Aceita aninhamento mas nao faz transition*/
    padding: 0 10px;
    background-color: #f9f9f9;
    display: none;
    overflow: hidden;
    margin-left: 0%;
  }
  .panelNested p {
    margin-left: 1%;
  }
  /*Inicio do Segundo Acordeon Aninhado*/
  button.accordionNestedTwo{
    background-color: #eee;
    color: #444;
    cursor: pointer;
    padding: 18px;
    width: 100%;
    border: none;
    text-align: left;
    outline: none;
    font-size: 15px;
    font-weight: bold;
  }
  .activeNestedTwo, .accordionNestedTwo:hover {
    background-color: #a4b8b6;
  }
  .panelNestedTwo {
    /*Aceita aninhamento mas nao faz transition*/
    padding: 0 10px;
    background-color: #f9f9f9;
    display: none;
    overflow: hidden;
    margin-left: 0%;
  }
  .panelNestedTwo p {
    margin-left: 1%;
  }
  /* Fim do menu tipo acordeon */
  
  .bloco .title {
      display: block;
  }
  
  /*Bloco de solucao de exercicio*/
  .bloco .label,
  .bloco .separator {
      font-weight: bold;
  }
  
  .bloco .separator {
      margin-right: .6em;
  /*    margin-left: .6em;  */
  }
  /* Solução */
  div.solucao {
    border-left: .3em solid #dd4444;   /*#dc3c01; */
    margin-left: -.8em;
    padding-left: .4em;
    position: relative;
    font-size: 90%;
  }
  
  div.solucao .conteudo {
    display: none;
    padding-top: 1px;
  }
  
  div.solucao button {
    color: #0000AF;
    background-color: white;
    border-radius: 5px;
  }
  
  div.solucao button.viewed {
    color: #FF2020;
    background-color: white;
    border-radius: 5px;
  }
  
  div.exemplo {
    /*background-color: lightgray;*/
    margin-left: 5%;
    margin-right: 5%;
  }
  
  div.exemplo .sourceCode  {
    /*background-color: lightgray;*/
    margin-left: 2%;
    margin-right: 2%;
  }
  
  div.adicional {
    margin-left: 1%;
  }
  /* Alinhamento dos títulos e parágrafos */
  
  body{margin-left: 5%; margin-right: 5%;
           color: black; background-color: #f9f9f9;}
  
  hr{
      margin-left: -4%;
      background-color: rgb(0,150,150);  /*anterior:    240,240,240 */
  }
  h1{
      margin-left: -4%;
      /*background-color: rgb(210,210,220);*/
  }
  
  h2{
      margin-left: -4%;
      /*background-color: rgb(220,220,230);*/
  }
  
  h3{
      margin-left: 0%;  /*-4%;*/
      /*background-color: rgb(230,230,240);*/
  }
  
  h4{
      margin-left: 0%;  /*-4%;*/
      /*background-color: rgb(240,240,250);*/
  }
  h5{
      margin-left: 0%;  /*-4%;*/
      /*background-color: rgb(245,245,250);*/
  }
  
  /* Cores */
  i{color: red}
  em{color: green}
  cite{color: brown}
  /* blockquote > p { */
  blockquote{color: red}
  blockquote p {
    margin-bottom: 0;
    font-size: 14px;
    font-weight: 300;
    line-height: 2em;
  }
  
  /* ---- Front Matter ----
  Pandoc header DIV. Contains .title, .author and .date. Comes before div#TOC.
  Only appears if one of those three are in the document.   */
  
  div#header, header
      {
      /* Put border on bottom. Separates it from TOC or body that comes after it. */
      border-bottom: 1px solid #aaa;
      margin-bottom: 0.5em;
      }
  
  .title /* Pandoc title header (h1.title) */
      {
      text-align: center;
      }
  
  .author, .date /* Pandoc author(s) and date headers (h2.author and h3.date) */
      {
      text-align: center;
      }
  
  /* Pandoc table of contents DIV when using the --toc option.
     NOTE: this doesn't support Pandoc's --id-prefix option for #TOC and #header.
     Probably would need to use div[id$='TOC'] and div[id$='header'] as selectors.
  */
  
  div#TOC, nav#TOC
      {
      /* Put border on bottom to separate it from body. */
  /*    border-bottom: 1px solid #aaa;   */
      margin-bottom: 0.5em;
      }
  
  @media print
      {
      div#TOC, nav#TOC
          {
          /* Don't display TOC in print */
          display: none;
          }
      }
  /* ---- Images ---- */
  img {
      /* Let it be inline left/right where it wants to be, but verticality make
         it in the middle to look nicer, but opinions differ, and if in a multi-line
         paragraph, it might not be so great.
         vertical-align: middle;
      */
      vertical-align: middle;
      max-width: 600px;
      height:auto;
      }
  div.figure /* Pandoc figure-style image */
      {
      /* Center the image and caption */
      margin-left: auto;
      margin-right: auto;
      text-align: center;
      font-style: italic;
      max-width: 600px;
      height:auto;
      }
  p.caption /* Pandoc figure-style caption within div.figure */
      {
      /* Inherits div.figure props by default */
      }
  /* ---- Tables ---- */
  table {
      margin-left: auto;
      margin-right: auto;
      margin-bottom: 24px;
      border-spacing: 0;
      border-bottom: 2px solid black;
      border-top: 2px solid black;
  }
  table th {
      padding: 3px 10px;
      background-color: white;
      border-top: 1px;
      border-left: 1px;
      border-right: 1px;
      border-bottom: 1px solid black;
  }
  table td {
      padding: 3px 10px;
      border-top: 1px;
      border-left: 1px;
      border-bottom: 1px;
      border-right: 1px;
  }
  /* fundo para as linhas das tabelas */
  tr.even{
    background-color: rgb(230,230,240);
  }
  tr.odd{
    background-color: rgb(250,250,250);
  }
  </style>
  
  
  <script type="text/javascript">
      function exibe(e)
      {
          var div = e.parentNode.firstElementChild;
          var nome = e.parentNode.id;
          var tipo=nome.substring(0, 3).toUpperCase()
          switch (tipo) {
            case "SOL":
                nome = "Solução";
                break;
            case "COD":
                nome = "Código";
                break;
            case "DIC":
                nome = "Dica";
                break;
            case "DIA":
                nome = "Diagrama";
                break;
            case "RES":
                nome = "Resumo";
                break;
            case "CON":
                nome = "Conteúdo";
                break;
            default:
                nome = "";
            }
  
          if (div.style.display == "" || div.style.display == "none") {
              div.style.display = "block";
              e.setAttribute("class", "viewed");
              e.innerHTML = "Esconder ";
          } else {
              div.style.display = "none";
              e.innerHTML = "Exibir "+nome;
          }
      }
      function validaBinario(nome) {
          var valor, tamanho, i;
          document.getElementById(nome).style.color = "black";
          valor = document.getElementById(nome).value;
          tamanho=valor.length;
          for (i=0;i<tamanho; i=i+1){
              if ( valor[i] != 1 && valor[i] != 0 ){
                  document.getElementById(nome).style.color = "red";
              }
          }
      }
  </script>
</head>
<body>
<p><br></p>
<h1 id="projeto-1-calculadora-utilizando-um-processador-personalizado">Projeto 1: Calculadora Utilizando um Processador Personalizado</h1>
<button class="accordionNested">
Descrição
</button>
<div class="panelNested">
<p>O objetivo do projeto é a implementação de um processador, que será utilizado em uma calculadora com as seguintes características (<strong>projeto mínimo</strong>):</p>
<ul>
<li><p>Trabalha somente com inteiros:</p>
<ul>
<li>Os valores de entrada e saída são de 16 bits (deve indicar estouro de faixa).</li>
</ul></li>
<li><p>Faz as operações aritméticas:</p>
<ul>
<li><p>Soma;</p></li>
<li><p>Subtração;</p></li>
<li><p>Multiplicação (utilizando a soma);</p></li>
<li><p>Divisão com resto (utilizando a subtração).</p></li>
</ul></li>
<li><p>Possui as operações lógicas: AND, OR, NOT e XOR;</p></li>
<li><p>A entrada dos operandos através das chaves da placa de FPGA;</p></li>
<li><p>A exibição através dos displays de sete segmentos.</p></li>
</ul>
<button class="accordion">
Características do Processador
</button>
<div class="panel">
<p>Características principais do projeto mínimo:</p>
<ul>
<li><p>Arquitetura Harvard;</p></li>
<li><p>Trabalha com dados de 8 bits.</p></li>
<li><p>Deve estar contido em um componente que possui uma interface externa com:</p>
<ul>
<li><p>Barramento de dados: 8 bits;</p></li>
<li><p>Barramento da memória de instruções: limitado a 16 bits (para acomodar o imediato);</p></li>
<li><p>Barramento de endereços: 16 bits (no máximo);</p></li>
<li><p>Barramento de controle: somente os sinais mais comuns (por exemplo, o R/~W);</p></li>
</ul></li>
</ul>
<blockquote>
<p><strong>Toda a decodificação de endereços deve ser feita fora do processador.</strong></p>
</blockquote>
<h3 id="dicas">Dicas</h3>
<p>Dê preferência aos componentes que:</p>
<ul>
<li><p>Já foram utilizados anteriormente;</p></li>
<li><p>Estão presentes na página de modelos;</p></li>
<li><p>São dos <em>templates</em> do Quartus.</p></li>
</ul>
<p><strong><font style="color:red;">Importante:<br> Não utilize as bibliotecas da Synopsys.<br> Veja na página interna, sobre VHDL, a especificação dessas bibliotecas. </font></strong></p>
</div>
<!--- class_panel --->
<button class="accordion">
Opcionais
</button>
<div class="panel">
<p>Adicionam meio conceito (ou o sinal de &quot;+&quot;) ao limite da nota do projeto (limitado a: A+):</p>
<ul>
<li><p>Montador (assembler) para o processador criado:</p>
<ul>
<li>Deve ser em Python.</li>
</ul></li>
<li><p>Multiplicação por hardware (não utilizar a biblioteca do IEEE):</p>
<ul>
<li>Consultem sobre qual implementação usar <strong>(ver link na seção de <em>Leituras</em>, abaixo)</strong>.</li>
</ul></li>
<li><p>Divisão por hardware (não utilizar a biblioteca do IEEE):</p>
<ul>
<li>Consultem sobre qual implementação usar <strong>(ver link na seção de <em>Leituras</em>, abaixo)</strong>.</li>
</ul></li>
<li><p>Exibição das mensagens e resultados no display de cristal líquido;</p></li>
<li><p>Varredura do teclado feita por hardware.</p></li>
</ul>
<p>Adicionam um conceito (sobe uma letra) ao limite da nota do projeto (limitado a: A+):</p>
<ul>
<li><p>Pilha controlada por hardware (instruções <em>push</em> e <em>pop</em> no processador):</p>
<ul>
<li>Pode ter a posição fixa na memória (não precisa iniciar o ponteiro da pilha).</li>
</ul></li>
<li><p>Instrução de chamada de sub-rotina com um nível:</p>
<ul>
<li><p>Não precisa atender chamadas aninhadas, ou seja, sem recursão;</p></li>
<li><p>O endereço de retorno, pode ser armazenado na pilha ou em registrador específico.</p></li>
<li><p>O destino pode ter como referência o PC ou ser absoluto.</p></li>
</ul></li>
</ul>
<blockquote>
<p><strong>Caso tenha ideia para algum opcional, confira antes se ele adiciona valor ao projeto.</strong></p>
</blockquote>
</div>
<!--- class_panel --->
<button class="accordion">
Entrega Intermediária
</button>
<div class="panel">
<p>Esta entrega é o pré projeto. Ela deve ser o resultado dos conhecimentos adquiridos nas atividades, da aula 1 até aula 7, e as justificativas para as escolhas feitas.</p>
<h3 id="organização-geral">Organização Geral</h3>
<p>A entrega intermediária, somente o processador e o esboço do projeto de hardware, será feita no dia 30/03/2021. A entrega com atraso será até o dia 04/04/2021, com desconto de um conceito, ou seja, uma letra. Após essa data, o projeto será considerado como não entregue.</p>
<p>A entrega é um único arquivo, do tipo PDF, com as informações sobre o grupo e o estado atual do projeto 1. Para facilitar o entendimento, todos os diagramas devem conter uma breve explicação do seu conteúdo.</p>
<p>Esse relatório inicial deve conter, no mínimo, os tópicos abaixo e as justificativas que levaram a cada decisão do projeto.</p>
<ul>
<li><p>Arquitetura do processador (acumulador, registrador memória ou registrador registrador);</p></li>
<li><p>Total de instruções e sua sintaxe (o nome de cada instrução com o tipo de argumento que ela utiliza);</p></li>
<li><p>Modos de endereçamento utilizados (direto, indexado, etc);</p></li>
<li><p>Formato das instruções (distribuição dos campos na palavra de instrução);</p></li>
<li><p>Fluxo de dados para o processador, com uma explicação resumida do seu funcionamento;</p></li>
<li><p>Listagem dos pontos de controle e sua utilização;</p></li>
<li><p>Rascunho do diagrama de conexão do processador com os periféricos;</p></li>
<li><p>Rascunho do mapa de memória.</p></li>
</ul>
<p>Caso tenha utilizado alguma informação ou esquema de terceiros, faça a devida atribuição.</p>
<p>As justificativas podem conter informações sobre a dificuldade de realização de cada item.</p>
</div>
<!--- class_panel --->
<button class="accordion">
Entrega Final
</button>
<div class="panel">
<p>A entrega final e apresentação do projeto será logo após a Avaliação Intermediária, em 15/04/2021. A entrega com atraso, será no dia 18/04/2021, com desconto de um conceito, ou seja, uma letra.</p>
<p>A avaliação do projeto final será feita através dos seguintes itens:</p>
<ul>
<li><p>Apresentação do projeto, no kit de desenvolvimento:</p>
<ul>
<li>Com arguição do(s) professor(es).</li>
</ul></li>
<li><p>Entrega de um resumo explicativo do funcionamento do circuito, contendo:</p>
<ul>
<li><p>Diagrama de blocos do projeto;</p></li>
<li><p>Com comentários (opcional) sobre os problemas encontrados.</p></li>
</ul></li>
<li><p>Entrega do projeto do Quartus, com:</p>
<ul>
<li>Código VHDL, <strong>devidamente documentado</strong> e com o nome dos participantes.</li>
</ul></li>
</ul>
<h3 id="execução">Execução</h3>
<p>Grupo: com no máximo dois alunos.</p>
</div>
<!--- class_panel --->
<button class="accordion">
Rubrica
</button>
<div class="panel">
<p><br></p>
<table style="width:99%;">
<caption><strong>Rubricas para o Projeto 1</strong></caption>
<colgroup>
<col width="6%" />
<col width="44%" />
<col width="38%" />
<col width="8%" />
</colgroup>
<thead>
<tr class="header">
<th align="center">Nota</th>
<th align="left">Critério</th>
<th align="left">Documentação</th>
<th align="center">Montador</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">A</td>
<td align="left">Entregou o projeto básico com uma quantidade de itens opcionais, funcionando adequadamente, que totalizem essa nota ou valor maior. Funciona sem erros.</td>
<td align="left">Código bem comentado. Manual com descrição do projeto e instruções de uso.</td>
<td align="center">Obrigatório</td>
</tr>
<tr class="even">
<td align="center">B</td>
<td align="left">Entregou o projeto básico com uma quantidade de itens opcionais, funcionando adequadamente, que totalizem essa nota. Funciona com pequenos erros (o critério é estabelecido pelo professor).</td>
<td align="left">Código bem comentado. Manual com descrição do projeto e instruções de uso.</td>
<td align="center">Opcional</td>
</tr>
<tr class="odd">
<td align="center">C</td>
<td align="left">Entregou o projeto básico. Funciona com pequenos erros (o critério é estabelecido pelo professor).</td>
<td align="left">Código comentado e um simples manual de instruções de uso.</td>
<td align="center">Opcional</td>
</tr>
<tr class="even">
<td align="center">D</td>
<td align="left">Entregou o projeto básico com erros graves ou incompleto.</td>
<td align="left">N.A.</td>
<td align="center">N.A.</td>
</tr>
<tr class="odd">
<td align="center">I</td>
<td align="left">Não entregou o projeto.</td>
<td align="left">N.A.</td>
<td align="center">N.A.</td>
</tr>
</tbody>
</table>
</div>
<!--- class_panel --->
<button class="accordion">
Leituras
</button>
<div class="panel">
<p>Livro texto (Organização e Projeto de Computadores: A Interface Hardware/Software):</p>
<ul>
<li><p>Capítulo 4, item 3 (construindo um fluxo de dados);</p></li>
<li><p><a href="../livro/Apendice_D-UnidadeControle.pdf">Apêndice D</a> completo. Trata de máquinas de estados, microprogramação e unidade de controle.</p></li>
<li><p>Sobre multiplicação e divisão por hardware, veja os <a href="../livro/Organizacao_e_Projeto_de_Computadores-P-H-4Ed-2014-Multiplicacao_e_Divisao.pdf">tópicos 3.3 e 3.4 do livro texto</a>.</p></li>
</ul>
<p>Caso queira ler mais, veja o livro do Stallings (Arquitetura e Organização de Computadores):</p>
<ul>
<li>Capítulos 14 e 15.</li>
</ul>
</div>
<!--- class_panel --->
</div>
<!--- class_panelNested --->
<p><br></p>
<hr />
<h1 id="projeto-2-processador-compatível-com-mips-dlx">Projeto 2: Processador compatível com MIPS DLX</h1>
<button class="accordionNested">
Descrição
</button>
<div class="panelNested">
<p>Este projeto será a implementação de um processador RISC de 32 bits, compatível com o MIPS DLX.</p>
<p>Teremos duas organizações para o processador: <em>ciclo-único</em> e <em>pipeline</em>. Além disso, também teremos dois grupos de instruções, definidos em <em>Opções de Grupos de Instruções</em> (abaixo).</p>
<p>A combinação entre as opções de organização e grupos de instruções definirá a nota máxima que poderá ser obtida no projeto.</p>
<h3 id="execução-1">Execução</h3>
<p>Em grupo com no máximo <strong>dois</strong> alunos.</p>
<button class="accordion">
Opções de Grupos de Instruções
</button>
<div class="panel">
<h3 id="grupo-a">Grupo A</h3>
<p>Quanto aos dois grupos de instruções, o <strong>subgrupo &quot;A&quot;</strong> é formado pelas instruções abaixo:</p>
<ul>
<li><p>As instruções de referência à memória:</p>
<ul>
<li><p>Carrega palavra (<em>load word: lw</em>);</p></li>
<li><p>Armazena palavra (<em>store word: sw</em>).</p></li>
</ul></li>
<li><p>As instruções lógico-aritméticas:</p>
<ul>
<li><p>Soma (<em>add</em>);</p></li>
<li><p>Subtração (<em>sub</em>);</p></li>
<li><p>E lógico (<em>AND</em>);</p></li>
<li><p>OU lógico (<em>OR</em>);</p></li>
<li><p>Comparação menor que (<em>set if less than: slt</em>).</p></li>
</ul></li>
<li><p>As instruções de desvio:</p>
<ul>
<li><p>Desvio se igual (<em>branch equal: beq</em>);</p></li>
<li><p>Salto incondicional (<em>jump: j</em>).</p></li>
</ul></li>
</ul>
<h3 id="grupo-b">Grupo B</h3>
<p>O <strong>subgrupo &quot;B&quot;</strong> possui as instruções do subgrupo &quot;A&quot; e adiciona as listadas abaixo:</p>
<ul>
<li><p>A instrução de carga:</p>
<ul>
<li>Carrega imediato para 16 bits MSB (<em>load upper immediate: lui</em>).</li>
</ul></li>
<li><p>As instruções lógico-aritméticas:</p>
<ul>
<li><p>Soma com imediato (<em>addi</em>);</p></li>
<li><p>E lógico com imediato (<em>ANDI</em>);</p></li>
<li><p>OU lógico com imediato (<em>ORI</em>);</p></li>
<li><p>Comparação menor que imediato (<em>set if less than: slti</em>).</p></li>
</ul></li>
<li><p>As instruções de desvio:</p>
<ul>
<li><p>Desvio se não igual (<em>branch not equal: bne</em>);</p></li>
<li><p>Salto e conecta (<em>jump and link: jal</em>);</p></li>
<li><p>Salto por registrador (<em>jump register: jr</em>).</p></li>
</ul></li>
</ul>
<p>Tal qual a implementação do livro texto, não trabalharemos com nenhuma das instruções de ponto flutuante. Também não implementaremos todas as instruções que trabalham com inteiros, por exemplo: deslocamento, multiplicação e divisão.</p>
<p>As instruções restantes, para completar o conjunto todo do MIPS DLX, poderão ser implementadas com as mesmas técnicas usadas para implementar estes subconjuntos.</p>
<!--
A interface com o usuário deverá conter:
<p><font style="color:red;font-size:20px;font-weight:bold;">Aviso: CONTINUAR</font></p>
<p><font style="color:red;font-size:20px;font-weight:bold;">Aviso: Colocar a rubrica padrão para projetos sem definição mais completa.</font></p>
-->
</div>
<!--- class_panel --->
<button class="accordion">
Entrega Intermediária
</button>
<div class="panel">
<p>Será a organização <em>ciclo único</em> e o <em>grupo de instruções A</em>.</p>
<table style="width:90%;">
<caption><strong>Rubricas para o Projeto 2 - Entrega Intermediária</strong></caption>
<colgroup>
<col width="6%" />
<col width="44%" />
<col width="38%" />
</colgroup>
<thead>
<tr class="header">
<th align="center">Nota</th>
<th align="left">Critério</th>
<th align="left">Documentação</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">A</td>
<td align="left">Entregou o projeto, com todas instruções do grupo A, funcionando sem erros.</td>
<td align="left">Código bem comentado. Manual com descrição do projeto e instruções de uso.</td>
</tr>
<tr class="even">
<td align="center">B</td>
<td align="left">Entregou o projeto, com todas instruções do grupo A funcionando. Porém, com pequenos erros (o critério é estabelecido pelo professor) em no máximo duas instruções.</td>
<td align="left">Código bem comentado. Manual com descrição do projeto e instruções de uso.</td>
</tr>
<tr class="odd">
<td align="center">C</td>
<td align="left">Entregou o projeto faltando uma instrução (do grupo A) ou com todas instruções, porém com pequenos erros (o critério é estabelecido pelo professor) em três ou mais instruções.</td>
<td align="left">Código comentado e um simples manual de instruções de uso.</td>
</tr>
<tr class="even">
<td align="center">D</td>
<td align="left">Entregou o projeto com erros graves ou incompleto (duas ou mais instruções faltando).</td>
<td align="left">N.A.</td>
</tr>
<tr class="odd">
<td align="center">I</td>
<td align="left">Não entregou o projeto.</td>
<td align="left">N.A.</td>
</tr>
</tbody>
</table>
<h3 id="data">Data</h3>
<!--  A ser definida. -->
<p><font style="color:red">A ser definida durante a aula.</font></p>
</div>
<!--- class_panel --->
<button class="accordion">
Entrega Final
</button>
<div class="panel">
<h3 id="combinações-entre-organização-e-grupos-de-instruções">Combinações entre Organização e Grupos de Instruções</h3>
<p>O projeto deverá implementar as seguintes funcionalidades:</p>
<ul>
<li><p>MIPS <em>single cycle</em> :</p>
<ul>
<li><p>Executando as instruções dos subconjuntos A e B;</p></li>
<li><p>Nota máxima: limitada ao C+.</p></li>
</ul></li>
<li><p>MIPS com <em>pipeline</em>:</p>
<ul>
<li><p>Executando todas instruções do subconjunto A;</p></li>
<li><p>Nota máxima: limitada ao B.</p></li>
<li><p>Caso sejam adicionadas as instruções abaixo, o limite da nota será B+.</p>
<ul>
<li><p>Salto e conecta (<em>jump and link: jal</em>);</p></li>
<li><p>Salto por registrador (<em>jump register: jr</em>).</p></li>
</ul></li>
</ul></li>
<li><p>MIPS com <em>pipeline</em>:</p>
<ul>
<li><p>Executando as instruções dos subconjuntos A e B;</p></li>
<li><p>Nota máxima: sem limite (A+).</p></li>
</ul></li>
</ul>
<table style="width:90%;">
<caption><strong>Rubricas para o Projeto 2 - Entrega Final</strong></caption>
<colgroup>
<col width="6%" />
<col width="44%" />
<col width="38%" />
</colgroup>
<thead>
<tr class="header">
<th align="center">Nota</th>
<th align="left">Critério</th>
<th align="left">Documentação</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">A+</td>
<td align="left">Entregou o projeto, na organização <em>pipeline</em>**, com todas instruções (grupos A e B) funcionando sem erros.</td>
<td align="left">Código bem comentado. Manual com descrição do projeto e instruções de uso.</td>
</tr>
<tr class="even">
<td align="center">A</td>
<td align="left">Entregou o projeto, na organização <em>pipeline</em>**, com todas instruções (grupos A e B). Porém, com pequenos erros* em no <strong>máximo duas instruções</strong>.</td>
<td align="left">Código bem comentado. Manual com descrição do projeto e instruções de uso.</td>
</tr>
<tr class="odd">
<td align="center">B+</td>
<td align="left">Entregou o projeto, na organização <em>pipeline</em>**, com as instruções do grupo A, funcionando sem erros.</td>
<td align="left">Código bem comentado. Manual com descrição do projeto e instruções de uso.</td>
</tr>
<tr class="even">
<td align="center">B</td>
<td align="left">Entregou o projeto, na organização <em>pipeline</em>**, com todas instruções do grupo A. Porém, com pequenos erros* em no <strong>máximo uma instrução</strong>.</td>
<td align="left">Código bem comentado. Manual com descrição do projeto e instruções de uso.</td>
</tr>
<tr class="odd">
<td align="center">C+</td>
<td align="left">Entregou o projeto, na organização <em>ciclo único</em>, com todas instruções dos grupos A e B. Porém, com pequenos erros* em no <strong>máximo uma instrução</strong>.</td>
<td align="left">Código comentado e um simples manual de instruções de uso.</td>
</tr>
<tr class="even">
<td align="center">C</td>
<td align="left">Entregou o projeto, na organização <em>ciclo único</em>, com todas instruções do grupo A e as instruções LUI e ORI. Porém, com pequenos erros* em no <strong>máximo uma instrução</strong>.</td>
<td align="left">Código comentado e um simples manual de instruções de uso.</td>
</tr>
<tr class="odd">
<td align="center">D</td>
<td align="left">Entregou o projeto com erros graves* ou incompleto (instruções faltando).</td>
<td align="left">N.A.</td>
</tr>
<tr class="even">
<td align="center">I</td>
<td align="left">Não entregou o projeto.</td>
<td align="left">N.A.</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>*O critério, sobre o que é um erro grave ou pequeno, é estabelecido pelo professor.</strong></p>
</blockquote>
<blockquote>
<p><strong>**Será fornecido um projeto base, testado, faltando a implementação dos registradores do <em>pipeline</em> e a UC. Assim, o trabalho dos grupos será menor, podendo ser realizado dentro do prazo de entrega.</strong></p>
</blockquote>
<h3 id="data-1">Data</h3>
<!-- A data de entrega, conforme o plano de aula, será: -->
<p>A data de entrega será:</p>
<ul>
<li><p>Dentro do prazo e com limite de nota definido nas opções de projeto: <strong>17/06/2021</strong>.</p></li>
<li><p><strong>Não haverá entrega em atraso.</strong></p></li>
</ul>
<!--
<p><font style="color:red;font-size:16px;font-weight:bold;">Será feito o agendamento da apresentação dos grupos, devendo ser apresentados, no mínimo, 6 grupos por dia.</font></p>
-->
<!---
-   Com atraso. O limite de nota é rebaixado em uma letra (em relação às opções de projeto): 22/11/2018.
--->
<h3 id="avaliação">Avaliação</h3>
<p>A avaliação do projeto segue o descrito no plano de aula. Ela será feita através dos seguintes itens:</p>
<ul>
<li><p>Apresentação do projeto, no kit de desenvolvimento:</p>
<ul>
<li>Com arguição do(s) professor(es).</li>
</ul></li>
</ul>
<!---
-   Entrega de um resumo explicativo do funcionamento do circuito, contendo:

    -   Diagrama de blocos do projeto;

    -   Diagrama de estados (se for o caso);

    -   Com comentários (opcional) sobre os problemas encontrados.
--->
<ul>
<li><p>Entrega do projeto do Quartus, com:</p>
<ul>
<li><p>Código VHDL, devidamente documentado e com o nome dos participantes;</p></li>
<li><p>Arquivo com conteúdo da microprogramação (se for o caso).</p></li>
<li><p>Manual de uso.</p></li>
</ul></li>
</ul>
<p><br></p>
</div>
<!--- class_panel --->
<button class="accordion">
Leituras
</button>
<div class="panel">
<p>Ler os itens abaixo, do livro texto (Organização e Projeto de Computadores: A Interface Hardware/Software):</p>
<ul>
<li><p>Capítulo 4, item 4.1 até 4.9;</p></li>
<li><p><a href="../livro/Apendice_C-ProjetoLogico.pdf">Apêndice C</a> do livro texto;</p></li>
<li><p><a href="../livro/Apendice_D-UnidadeControle.pdf">Apêndice D</a> do livro texto;</p></li>
<li><p><a href="https://en.wikipedia.org/wiki/MIPS_architecture">Arquitetura do MIPS na wikipedia (nosso interesse: MIPS I).</a> {}</p></li>
<li><p><a href="https://en.wikipedia.org/wiki/DLX">A página do DLX na wikipedia.</a></p></li>
<li><p>Um resumo de <a href="https://booksite.elsevier.com/9780124077263/downloads/COD_5e_Greencard.pdf">referência sobre o MIPS</a> (todas instruções e outros detalhes - download gratuito no site da editora).</p></li>
<li><p>Resumo (interno) da <a href="../MIPS/_arquitetura.html">arquitetura do MIPS</a></p></li>
</ul>
</div>
<!--- class_panel --->
</div>
<!--- class_panelNested --->
<button class="accordionNested">
Programas de Teste para o MIPS DLX
</button>
<div class="panelNested">

<p>A seguir estão os arquivos, do tipo <em>.mif</em>, com os programas de teste.</p>
<button class="accordion">
Ciclo Único e Subconjunto A
</button>
<div class="panel">
<p>Inicialização do Banco de Registradores em VHDL:</p>
<div class="sourceCode"><pre class="sourceCode asm"><code class="sourceCode fasm">function initMemory
        return memoria_t is variable tmp : memoria_t := (others =&gt; (others =&gt; <span class="st">&#39;0&#39;</span>))<span class="co">;</span>
  begin
        -- Inicializa os endereços:
        tmp(<span class="dv">8</span>)  := 32x<span class="st">&quot;00&quot;</span><span class="co">;  -- $t0 = 0x00</span>
        tmp(<span class="dv">9</span>)  := 32x<span class="st">&quot;0A&quot;</span><span class="co">;  -- $t1 = 0x0A</span>
        tmp(<span class="dv">10</span>) := 32x<span class="st">&quot;0B&quot;</span><span class="co">;  -- $t2 = 0x0B</span>
        tmp(<span class="dv">11</span>) := 32x<span class="st">&quot;0C&quot;</span><span class="co">;  -- $t3 = 0x0C</span>
        tmp(<span class="dv">12</span>) := 32x<span class="st">&quot;0D&quot;</span><span class="co">;  -- $t4 = 0x0D</span>
        tmp(<span class="dv">13</span>) := 32x<span class="st">&quot;16&quot;</span><span class="co">;  -- $t5 = 0x16</span>
        return tmp<span class="co">;</span>
    <span class="pp">end</span> initMemory<span class="co">;</span></code></pre></div>
<p><br></p>
<p>Conteúdo do <em>.mif</em> da ROM:</p>
<div class="sourceCode"><pre class="sourceCode asm"><code class="sourceCode fasm">
-- Copyright (C) <span class="dv">2017</span>  Intel Corporation. All rights reserved.
-- Your use of Intel Corporation<span class="st">&#39;s design tools, logic functions</span>
-- <span class="bu">and</span> other software <span class="bu">and</span> tools, <span class="bu">and</span> its AMPP partner logic
-- functions, <span class="bu">and</span> any output files <span class="bu">from</span> any of the foregoing
-- (including device programming <span class="bu">or</span> simulation files), <span class="bu">and</span> any
-- associated documentation <span class="bu">or</span> information are expressly subject
-- to the terms <span class="bu">and</span> conditions of the Intel Program License
-- Subscription Agreement, the Intel Quartus Prime License Agreement,
-- the Intel FPGA IP License Agreement, <span class="bu">or</span> other applicable license
-- agreement, including, without limitation, that your use is for
-- the sole purpose of programming logic devices manufactured by
-- Intel <span class="bu">and</span> sold by Intel <span class="bu">or</span> its authorized distributors.  Please
-- refer to the applicable agreement for further details.

WIDTH=<span class="dv">32</span><span class="co">;</span>
DEPTH=<span class="dv">64</span><span class="co">;</span>
ADDRESS_RADIX=<span class="bu">DEC</span><span class="co">;</span>
DATA_RADIX=HEX<span class="co">;</span>

CONTENT BEGIN
      -- Valores iniciais no banco de registradores:
      -- <span class="dv">$</span>t0   (#<span class="dv">8</span>) :=<span class="bn"> 0x00</span>
      -- <span class="dv">$</span>t1   (#<span class="dv">9</span>) :=<span class="bn"> 0x0A</span>
      -- <span class="dv">$</span>t2  (#<span class="dv">10</span>) :=<span class="bn"> 0x0B</span>
      -- <span class="dv">$</span>t3  (#<span class="dv">11</span>) :=<span class="bn"> 0x0C</span>
      -- <span class="dv">$</span>t4  (#<span class="dv">12</span>) :=<span class="bn"> 0x0D</span>
      -- <span class="dv">$</span>t5  (#<span class="dv">13</span>) :=<span class="bn"> 0x16</span>

    <span class="dv">0</span>    :   AC090008<span class="co">; --sw $t1 8($zero)     (m(8) := 0x0000000A)</span>
    <span class="dv">1</span>    :   8C080008<span class="co">; --lw $t0 8($zero)     ($t0  := 0x0000000A)</span>
    <span class="dv">2</span>    :   012A4022<span class="co">; --sub $t0 $t1 $t2     ($t0  := 0xFFFFFFFF)</span>
    <span class="dv">3</span>    :   012A4024<span class="co">; --and $t0 $t1 $t2     ($t0  := 0x0000000A)</span>
    <span class="dv">4</span>    :   012A4025<span class="co">; --or $t0 $t1 $t2      ($t0  := 0x0000000B)</span>
    <span class="dv">5</span>    :   012A402A<span class="co">; --slt $t0 $t1 $t2     ($t0  := 0x00000001)</span>
    <span class="dv">6</span>    :   010A4020<span class="co">; --add $t0 $t0 $t2     ($t0  := 0x0000000C)</span>
                       --segunda execução:   (<span class="dv">$</span>t0 := <span class="bn">0x00000017</span>)
    <span class="dv">7</span>    :   110BFFFE<span class="co">; --beq $t0 $t3 0xFFFE  (pc := #6)</span>
                       --segunda execução:   (pc := #<span class="dv">8</span>)
    <span class="dv">8</span>    :   <span class="dv">08000000</span><span class="co">; --j 0x000000          (pc := #0)</span>
<span class="pp">END</span><span class="co">;</span></code></pre></div>
<p><br></p>
<p>Sequência da execução do programa:</p>
<table>
<caption><strong>Resultados da Execução: Ciclo Único e Conjunto A</strong></caption>
<thead>
<tr class="header">
<th align="center">PC Dec</th>
<th align="center">PC Hex</th>
<th align="center"></th>
<th align="left">Saída ULA</th>
<th align="left">Instrução</th>
<th align="left">Comentário</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">00</td>
<td align="center">0x00</td>
<td align="center"></td>
<td align="left">0x08</td>
<td align="left">sw $t1 8($zero)</td>
<td align="left">M(8) := 0x0000000A</td>
</tr>
<tr class="even">
<td align="center">04</td>
<td align="center">0x04</td>
<td align="center"></td>
<td align="left">0x08</td>
<td align="left">lw $t0 8($zero)</td>
<td align="left">$t0 := 0x0000000A</td>
</tr>
<tr class="odd">
<td align="center">08</td>
<td align="center">0x08</td>
<td align="center"></td>
<td align="left">0xFFFFFFFF</td>
<td align="left">sub $t0 $t1 $t2</td>
<td align="left">$t0 := 0xFFFFFFFF</td>
</tr>
<tr class="even">
<td align="center">12</td>
<td align="center">0x0C</td>
<td align="center"></td>
<td align="left">0x000000A</td>
<td align="left">and $t0 $t1 $t2</td>
<td align="left">$t0 := 0x0000000A</td>
</tr>
<tr class="odd">
<td align="center">16</td>
<td align="center">0x10</td>
<td align="center"></td>
<td align="left">0x000000B</td>
<td align="left">or $t0 $t1 $t2</td>
<td align="left">$t0 := 0x0000000B</td>
</tr>
<tr class="even">
<td align="center">20</td>
<td align="center">0x14</td>
<td align="center"></td>
<td align="left">0x0000001</td>
<td align="left">slt $t0 $t1 $t2</td>
<td align="left">$t0 := 0x00000001</td>
</tr>
<tr class="odd">
<td align="center">24</td>
<td align="center">0x18</td>
<td align="center"></td>
<td align="left">0x000000C</td>
<td align="left">add $t0 $t0 $t2</td>
<td align="left">$t0 := 0x0000000C</td>
</tr>
<tr class="even">
<td align="center">28</td>
<td align="center">0x1C</td>
<td align="center"></td>
<td align="left">0x0000000</td>
<td align="left">beq $t0 $t3 0xFFFE</td>
<td align="left">pc := 0x18</td>
</tr>
<tr class="odd">
<td align="center">24</td>
<td align="center">0x18</td>
<td align="center"></td>
<td align="left">0x0000017</td>
<td align="left">add $t0 $t0 $t2</td>
<td align="left">$t0 := 0x00000017</td>
</tr>
<tr class="even">
<td align="center">28</td>
<td align="center">0x1C</td>
<td align="center"></td>
<td align="left">0x000000B</td>
<td align="left">beq $t0 $t3 0xFFFE</td>
<td align="left">pc := 0x20</td>
</tr>
<tr class="odd">
<td align="center">32</td>
<td align="center">0x20</td>
<td align="center"></td>
<td align="left">0x0000000</td>
<td align="left">j 0x000000</td>
<td align="left">Volta ao Início</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<!--- class_panel --->
<button class="accordion">
Ciclo Único, Subconjunto A, LUI e ORI
</button>
<div class="panel">
<p>
<font style="color:red;font-weight:bold;">Não é necessário inicializar o Banco de Registradores. Isso será feito através do LUI e ORI.</font>
</p>
<p>Conteúdo do <em>.mif</em> da ROM:</p>
<div class="sourceCode"><pre class="sourceCode asm"><code class="sourceCode fasm">
-- Copyright (C) <span class="dv">2017</span>  Intel Corporation. All rights reserved.
-- Your use of Intel Corporation<span class="st">&#39;s design tools, logic functions</span>
-- <span class="bu">and</span> other software <span class="bu">and</span> tools, <span class="bu">and</span> its AMPP partner logic
-- functions, <span class="bu">and</span> any output files <span class="bu">from</span> any of the foregoing
-- (including device programming <span class="bu">or</span> simulation files), <span class="bu">and</span> any
-- associated documentation <span class="bu">or</span> information are expressly subject
-- to the terms <span class="bu">and</span> conditions of the Intel Program License
-- Subscription Agreement, the Intel Quartus Prime License Agreement,
-- the Intel FPGA IP License Agreement, <span class="bu">or</span> other applicable license
-- agreement, including, without limitation, that your use is for
-- the sole purpose of programming logic devices manufactured by
-- Intel <span class="bu">and</span> sold by Intel <span class="bu">or</span> its authorized distributors.  Please
-- refer to the applicable agreement for further details.

WIDTH=<span class="dv">32</span><span class="co">;</span>
DEPTH=<span class="dv">64</span><span class="co">;</span>
ADDRESS_RADIX=<span class="bu">DEC</span><span class="co">;</span>
DATA_RADIX=HEX<span class="co">;</span>

CONTENT BEGIN
    -- Inicialização do Banco de Registradores:
    <span class="dv">0</span>   :   <span class="dv">00004020</span><span class="co">; --add $t0, $0, $0;    ($t0  := 0x00000000)</span>
    <span class="dv">1</span>   :   3C090000<span class="co">; --lui $t1, 0x0000;</span>
    <span class="dv">2</span>   :   3529000A<span class="co">; --ori $t1, $t1, 0x0A;   ($t1  := 0x0000000A)</span>
    <span class="dv">3</span>   :   3C0A0000<span class="co">; --lui $t2, 0x0000;</span>
    <span class="dv">4</span>   :   354A000B<span class="co">; --ori $t2, $t2, 0x0B;   ($t2  := 0x0000000B)</span>
    <span class="dv">5</span>   :   3C0B0000<span class="co">; --lui $t3, 0x0000;</span>
    <span class="dv">6</span>   :   356B000C<span class="co">; --ori $t3, $t3, 0x0C;   ($t3  := 0x0000000C)</span>
    <span class="dv">7</span>   :   3C0C0000<span class="co">; --lui $t4, 0x0000;</span>
    <span class="dv">8</span>   :   358C000D<span class="co">; --ori $t4, $t4, 0x0D;   ($t4  := 0x0000000D)</span>
    <span class="dv">9</span>   :   3C0D0000<span class="co">; --lui $t5, 0x0000;</span>
    <span class="dv">10</span>  :   35AD8016<span class="co">; --ori $t5, $t5, 0x8016;   ($t5  := 0x00008016)</span>

    -- Ponteiro para o segmento de dados na RAM:
    <span class="dv">11</span>   :   3C0F0000<span class="co">; --lui $t7, 0x0000;</span>
    <span class="dv">12</span>   :   35EF0000<span class="co">; --ori $t7, $t7, 0x0000;   ($t7  := 0x00000000)</span>

    -- O restante é igual ao teste do subconjunto A:
    <span class="dv">13</span>    :   AC090008<span class="co">; --sw $t1 8($t7)     (m(8) := 0x0000000A)</span>
    <span class="dv">14</span>    :   8C080008<span class="co">; --lw $t0 8($t7)     ($t0  := 0x0000000A)</span>
    <span class="dv">15</span>    :   012A4022<span class="co">; --sub $t0 $t1 $t2     ($t0  := 0xFFFFFFFF)</span>
    <span class="dv">16</span>    :   012A4024<span class="co">; --and $t0 $t1 $t2     ($t0  := 0x0000000A)</span>
    <span class="dv">17</span>    :   012A4025<span class="co">; --or $t0 $t1 $t2      ($t0  := 0x0000000B)</span>
    <span class="dv">18</span>    :   012A402A<span class="co">; --slt $t0 $t1 $t2     ($t0  := 0x00000001)</span>
    <span class="dv">19</span>    :   010A4020<span class="co">; --add $t0 $t0 $t2     ($t0  := 0x0000000C)</span>
                       --segunda execução:   (<span class="dv">$</span>t0 := <span class="bn">0x00000017</span>)
    <span class="dv">20</span>    :   110BFFFE<span class="co">; --beq $t0 $t3 0xFFFE  (pc := #19)</span>
                       --segunda execução:   (pc := #<span class="dv">21</span>)
    <span class="dv">21</span>    :   <span class="dv">08000000</span><span class="co">; --j 0x000000          (pc := #0)</span>
    [<span class="dv">22</span>..<span class="dv">63</span>]  : <span class="dv">00000000</span><span class="co">;</span>
<span class="pp">END</span><span class="co">;</span></code></pre></div>
<p><br></p>
<p>Sequência da execução do programa:</p>
<table>
<caption><strong>Resultados da Execução: Ciclo Único, Conjunto A, LUI e ORI</strong></caption>
<thead>
<tr class="header">
<th align="center">PC Dec</th>
<th align="center">PC Hex</th>
<th align="center"></th>
<th align="left">Saída ULA</th>
<th align="left">Instrução</th>
<th align="left">Comentário</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">00</td>
<td align="center">0x00</td>
<td align="center"></td>
<td align="left">0x00000000</td>
<td align="left">add $t0 $0 $0</td>
<td align="left">$t0 := 0x00000000</td>
</tr>
<tr class="even">
<td align="center">04</td>
<td align="center">0x04</td>
<td align="center"></td>
<td align="left">0xXXXXXXXX</td>
<td align="left">lui $t1 0x0000</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="center">08</td>
<td align="center">0x08</td>
<td align="center"></td>
<td align="left">0x0000000A</td>
<td align="left">ori $t1 $t1 0x0A</td>
<td align="left">$t1 := 0x0000000A</td>
</tr>
<tr class="even">
<td align="center">12</td>
<td align="center">0x0C</td>
<td align="center"></td>
<td align="left">0xXXXXXXXX</td>
<td align="left">lui $t2 0x0000</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="center">16</td>
<td align="center">0x10</td>
<td align="center"></td>
<td align="left">0x0000000B</td>
<td align="left">ori $t2 $t2 0x0B</td>
<td align="left">$t2 := 0x0000000B</td>
</tr>
<tr class="even">
<td align="center">20</td>
<td align="center">0x14</td>
<td align="center"></td>
<td align="left">0xXXXXXXXX</td>
<td align="left">lui $t3 0x0000</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="center">24</td>
<td align="center">0x18</td>
<td align="center"></td>
<td align="left">0x0000000C</td>
<td align="left">ori $t3 $t3 0x0C</td>
<td align="left">$t3 := 0x0000000C</td>
</tr>
<tr class="even">
<td align="center">28</td>
<td align="center">0x1C</td>
<td align="center"></td>
<td align="left">0xXXXXXXXX</td>
<td align="left">lui $t4 0x0000</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="center">32</td>
<td align="center">0x20</td>
<td align="center"></td>
<td align="left">0x0000000D</td>
<td align="left">ori $t4 $t4 0x0D</td>
<td align="left">$t4 := 0x0000000D</td>
</tr>
<tr class="even">
<td align="center">36</td>
<td align="center">0x24</td>
<td align="center"></td>
<td align="left">0xXXXXXXXX</td>
<td align="left">lui $t5 0x0000</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="center">40</td>
<td align="center">0x28</td>
<td align="center"></td>
<td align="left">0x00008016</td>
<td align="left">ori $t5 $t5 0x8016</td>
<td align="left">$t5 := 0x00008016</td>
</tr>
<tr class="even">
<td align="center">44</td>
<td align="center">0x2C</td>
<td align="center"></td>
<td align="left">0xXXXXXXXX</td>
<td align="left">lui $t7 0x0000</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="center">48</td>
<td align="center">0x30</td>
<td align="center"></td>
<td align="left">0x00000000</td>
<td align="left">ori $t7 $t7 0x0000</td>
<td align="left">$t7 := 0x00000000</td>
</tr>
<tr class="even">
<td align="center">52</td>
<td align="center">0x34</td>
<td align="center"></td>
<td align="left">0x00000008</td>
<td align="left">sw $t1 8($t7)</td>
<td align="left">M(8) := 0x0000000A</td>
</tr>
<tr class="odd">
<td align="center">56</td>
<td align="center">0x38</td>
<td align="center"></td>
<td align="left">0x00000008</td>
<td align="left">lw $t0 8($t7)</td>
<td align="left">$t0 := 0x0000000A</td>
</tr>
<tr class="even">
<td align="center">60</td>
<td align="center">0x3C</td>
<td align="center"></td>
<td align="left">0xFFFFFFFF</td>
<td align="left">sub $t0 $t1 $t2</td>
<td align="left">$t0 := 0xFFFFFFFF</td>
</tr>
<tr class="odd">
<td align="center">64</td>
<td align="center">0x40</td>
<td align="center"></td>
<td align="left">0x0000000A</td>
<td align="left">and $t0 $t1 $t2</td>
<td align="left">$t0 := 0x0000000A</td>
</tr>
<tr class="even">
<td align="center">68</td>
<td align="center">0x44</td>
<td align="center"></td>
<td align="left">0x0000000B</td>
<td align="left">or $t0 $t1 $t2</td>
<td align="left">$t0 := 0x0000000B</td>
</tr>
<tr class="odd">
<td align="center">72</td>
<td align="center">0x48</td>
<td align="center"></td>
<td align="left">0x00000001</td>
<td align="left">slt $t0 $t1 $t2</td>
<td align="left">$t0 := 0x00000001</td>
</tr>
<tr class="even">
<td align="center">76</td>
<td align="center">0x4C</td>
<td align="center"></td>
<td align="left">0x0000000C</td>
<td align="left">add $t0 $t0 $t2</td>
<td align="left">$t0 := 0x0000000C</td>
</tr>
<tr class="odd">
<td align="center">80</td>
<td align="center">0x50</td>
<td align="center"></td>
<td align="left">0x00000000</td>
<td align="left">beq $t0 $t3 0xFFFE</td>
<td align="left">pc := 0x4C</td>
</tr>
<tr class="even">
<td align="center">76</td>
<td align="center">0x4C</td>
<td align="center"></td>
<td align="left">0x00000017</td>
<td align="left">add $t0 $t0 $t2</td>
<td align="left">$t0 := 0x00000017</td>
</tr>
<tr class="odd">
<td align="center">80</td>
<td align="center">0x50</td>
<td align="center"></td>
<td align="left">0x0000000B</td>
<td align="left">beq $t0 $t3 0xFFFE</td>
<td align="left">pc := 0x54</td>
</tr>
<tr class="even">
<td align="center">84</td>
<td align="center">0x54</td>
<td align="center"></td>
<td align="left">0x00000000</td>
<td align="left">j 0x00000000</td>
<td align="left">Volta ao Início</td>
</tr>
</tbody>
</table>
</div>
<!--- class_panel --->
<button class="accordion">
Ciclo Único e Subconjuntos A e B
</button>
<div class="panel">
<p><strong>Teste de todas instruções:</strong></p>
<p>Conteúdo do <em>.mif</em> da ROM:</p>
<div class="sourceCode"><pre class="sourceCode asm"><code class="sourceCode fasm">
-- Copyright (C) <span class="dv">2017</span>  Intel Corporation. All rights reserved.
-- Your use of Intel Corporation<span class="st">&#39;s design tools, logic functions</span>
-- <span class="bu">and</span> other software <span class="bu">and</span> tools, <span class="bu">and</span> its AMPP partner logic
-- functions, <span class="bu">and</span> any output files <span class="bu">from</span> any of the foregoing
-- (including device programming <span class="bu">or</span> simulation files), <span class="bu">and</span> any
-- associated documentation <span class="bu">or</span> information are expressly subject
-- to the terms <span class="bu">and</span> conditions of the Intel Program License
-- Subscription Agreement, the Intel Quartus Prime License Agreement,
-- the Intel FPGA IP License Agreement, <span class="bu">or</span> other applicable license
-- agreement, including, without limitation, that your use is for
-- the sole purpose of programming logic devices manufactured by
-- Intel <span class="bu">and</span> sold by Intel <span class="bu">or</span> its authorized distributors.  Please
-- refer to the applicable agreement for further details.

WIDTH=<span class="dv">32</span><span class="co">;</span>
DEPTH=<span class="dv">64</span><span class="co">;</span>
ADDRESS_RADIX=<span class="bu">DEC</span><span class="co">;</span>
DATA_RADIX=HEX<span class="co">;</span>

CONTENT BEGIN
      -- Valores iniciais no banco de registradores:
      -- <span class="dv">$</span>t0   (#<span class="dv">8</span>) :=<span class="bn"> 0x00</span>
      -- <span class="dv">$</span>t1   (#<span class="dv">9</span>) :=<span class="bn"> 0x0A</span>
      -- <span class="dv">$</span>t2  (#<span class="dv">10</span>) :=<span class="bn"> 0x0B</span>
      -- <span class="dv">$</span>t3  (#<span class="dv">11</span>) :=<span class="bn"> 0x0C</span>
      -- <span class="dv">$</span>t4  (#<span class="dv">12</span>) :=<span class="bn"> 0x0D</span>
      -- <span class="dv">$</span>t5  (#<span class="dv">13</span>) :=<span class="bn"> 0x16</span>

    <span class="dv">0</span>    :   AC090008<span class="co">; --sw $t1 8($zero)     (m(8) := 0x0000000A)</span>
    <span class="dv">1</span>    :   8C080008<span class="co">; --lw $t0 8($zero)     ($t0 := 0x0000000A)</span>
    <span class="dv">2</span>    :   012A4022<span class="co">; --sub $t0 $t1 $t2     ($t0 := 0xFFFFFFFF)</span>
    <span class="dv">3</span>    :   012A4024<span class="co">; --and $t0 $t1 $t2     ($t0 := 0x0000000A)</span>
    <span class="dv">4</span>    :   012A4025<span class="co">; --or $t0 $t1 $t2      ($t0 := 0x0000000B)</span>
    <span class="dv">5</span>    :   3C08FFFF<span class="co">; --lui $t0 0xFFFF      ($t0 := 0xFFFF0000)</span>
    <span class="dv">6</span>    :   2128000A<span class="co">; --addi $t0 $t1 0x000A ($t0 := 0x00000014)</span>
    <span class="dv">7</span>    :   <span class="dv">31080013</span><span class="co">; --andi $t0 $t0 0x0013 ($t0 := 0x00000010)</span>
    <span class="dv">8</span>    :   <span class="dv">35880007</span><span class="co">; --ori $t0 $t4 0x0007  ($t0 := 0x0000000F)</span>
    <span class="dv">9</span>    :   2928FFFF<span class="co">; --slti $t0 $t1 0xFFFF ($t0 := 0x00000000)</span>
    <span class="dv">10</span>   :   010A4020<span class="co">; --add $t0 $t0 $t2     ($t0 := 0x0000000B)</span>
                          --segunda execução (<span class="dv">$</span>t0 := <span class="bn">0x00000016</span>)
    <span class="dv">11</span>   :   150DFFFE<span class="co">; --bne $t0 $t5 0xFFFE  (pc := #10)</span>
                          --segunda execução (pc := #<span class="dv">12</span>)
    <span class="dv">12</span>   :   012A402A<span class="co">; --slt $t0 $t1 $t2     ($t0 := 0x00000001)</span>
    <span class="dv">13</span>   :   010A4020<span class="co">; --add $t0 $t0 $t2     ($t0 := 0x0000000C)</span>
                          --segunda execução (<span class="dv">$</span>t0 := <span class="bn">0x00000017</span>)
    <span class="dv">14</span>   :   110BFFFE<span class="co">; --beq $t0 $t3 0xFFFE  (pc := #13)</span>
                          --segunda execução (pc := #<span class="dv">15</span>)
    <span class="dv">15</span>   :   0C00001F<span class="co">; --jal 0x00001F        (pc := #31)</span>
    <span class="dv">17</span>   :   <span class="dv">08000000</span><span class="co">; --j 0x000000          (pc := #0)</span>
    <span class="dv">31</span>   :   <span class="fl">03E00008</span><span class="co">; --jr $ra              (pc := #17)</span>
<span class="pp">END</span><span class="co">;</span></code></pre></div>
<p><br></p>
<table>
<caption><strong>Resultados da Execução: Ciclo Único com Conjuntos A e B</strong></caption>
<thead>
<tr class="header">
<th align="center">PC Dec</th>
<th align="center">PC Hex</th>
<th align="center"></th>
<th align="left">Saída ULA</th>
<th align="left">Instrução</th>
<th align="left">Comentário</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">00</td>
<td align="center">0x00</td>
<td align="center"></td>
<td align="left">0x00000008</td>
<td align="left">sw $t1 8($zero)</td>
<td align="left">M(8) := 0x0000000A</td>
</tr>
<tr class="even">
<td align="center">04</td>
<td align="center">0x04</td>
<td align="center"></td>
<td align="left">0x00000008</td>
<td align="left">lw $t0 8($zero)</td>
<td align="left">$t0 := 0x0000000A</td>
</tr>
<tr class="odd">
<td align="center">08</td>
<td align="center">0x08</td>
<td align="center"></td>
<td align="left">0xFFFFFFFF</td>
<td align="left">sub $t0 $t1 $t2</td>
<td align="left">$t0 := 0xFFFFFFFF</td>
</tr>
<tr class="even">
<td align="center">12</td>
<td align="center">0x0C</td>
<td align="center"></td>
<td align="left">0x0000000A</td>
<td align="left">and $t0 $t1 $t2</td>
<td align="left">$t0 := 0x0000000A</td>
</tr>
<tr class="odd">
<td align="center">16</td>
<td align="center">0x10</td>
<td align="center"></td>
<td align="left">0x0000000B</td>
<td align="left">or $t0 $t1 $t2</td>
<td align="left">$t0 := 0x0000000B</td>
</tr>
<tr class="even">
<td align="center">20</td>
<td align="center">0x14</td>
<td align="center"></td>
<td align="left">0xFFFF0000</td>
<td align="left">lui $t0 0xFFFF</td>
<td align="left">$t0 := 0xFFFF0000</td>
</tr>
<tr class="odd">
<td align="center">24</td>
<td align="center">0x18</td>
<td align="center"></td>
<td align="left">0x00000014</td>
<td align="left">addi $t0 $t1 0x000A</td>
<td align="left">$t0 := 0x00000014</td>
</tr>
<tr class="even">
<td align="center">28</td>
<td align="center">0x1C</td>
<td align="center"></td>
<td align="left">0x00000010</td>
<td align="left">andi $t0 $t0 0x0013</td>
<td align="left">$t0 := 0x00000010</td>
</tr>
<tr class="odd">
<td align="center">32</td>
<td align="center">0x20</td>
<td align="center"></td>
<td align="left">0x0000000F</td>
<td align="left">ori $t0 $t4 0x0007</td>
<td align="left">$t0 := 0x0000000F</td>
</tr>
<tr class="even">
<td align="center">36</td>
<td align="center">0x24</td>
<td align="center"></td>
<td align="left">0x00000000</td>
<td align="left">slti $t0 $t1 0xFFFF</td>
<td align="left">$t0 := 0x00000000</td>
</tr>
<tr class="odd">
<td align="center">40</td>
<td align="center">0x28</td>
<td align="center"></td>
<td align="left">0x0000000B</td>
<td align="left">add $t0 $t0 $t2</td>
<td align="left">$t0 := 0x0000000B</td>
</tr>
<tr class="even">
<td align="center">44</td>
<td align="center">0x2C</td>
<td align="center"></td>
<td align="left">0xFFFFFFF5</td>
<td align="left">bne $t0 $t5 0xFFFE</td>
<td align="left">pc := 0x28</td>
</tr>
<tr class="odd">
<td align="center">40</td>
<td align="center">0x28</td>
<td align="center"></td>
<td align="left">0x00000016</td>
<td align="left">add $t0 $t0 $t2</td>
<td align="left">$t0 := 0x00000016</td>
</tr>
<tr class="even">
<td align="center">44</td>
<td align="center">0x2C</td>
<td align="center"></td>
<td align="left">0x00000000</td>
<td align="left">bne $t0 $t5 0xFFFE</td>
<td align="left">pc := 0x30</td>
</tr>
<tr class="odd">
<td align="center">48</td>
<td align="center">0x30</td>
<td align="center"></td>
<td align="left">0x00000001</td>
<td align="left">slt $t0 $t1 $t2</td>
<td align="left">$t0 := 0x00000001</td>
</tr>
<tr class="even">
<td align="center">52</td>
<td align="center">0x34</td>
<td align="center"></td>
<td align="left">0x0000000C</td>
<td align="left">add $t0 $t0 $t2</td>
<td align="left">$t0 := 0x0000000C</td>
</tr>
<tr class="odd">
<td align="center">56</td>
<td align="center">0x38</td>
<td align="center"></td>
<td align="left">0x00000000</td>
<td align="left">beq $t0 $t3 0xFFFE</td>
<td align="left">pc := 0x34</td>
</tr>
<tr class="even">
<td align="center">52</td>
<td align="center">0x34</td>
<td align="center"></td>
<td align="left">0x00000017</td>
<td align="left">add $t0 $t0 $t2</td>
<td align="left">$t0 := 0x00000017</td>
</tr>
<tr class="odd">
<td align="center">56</td>
<td align="center">0x38</td>
<td align="center"></td>
<td align="left">0x0000000B</td>
<td align="left">beq $t0 $t3 0xFFFE</td>
<td align="left">pc := 0x3C</td>
</tr>
<tr class="even">
<td align="center">60</td>
<td align="center">0x3C</td>
<td align="center"></td>
<td align="left">0xXXXXXXXX</td>
<td align="left">jal 0x00001F</td>
<td align="left">&lt;&lt; 0x1F := 0x7C</td>
</tr>
<tr class="odd">
<td align="center">124</td>
<td align="center">0x7C</td>
<td align="center"></td>
<td align="left">0xXXXXXXXX</td>
<td align="left">jr $ra</td>
<td align="left">pc := 0x40</td>
</tr>
<tr class="even">
<td align="center">64</td>
<td align="center">0x40</td>
<td align="center"></td>
<td align="left">0xXXXXXXXX</td>
<td align="left">nop</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="center">68</td>
<td align="center">0x44</td>
<td align="center"></td>
<td align="left">0xXXXXXXXX</td>
<td align="left">j 0x000000</td>
<td align="left">Volta ao Início</td>
</tr>
</tbody>
</table>
<!--

**Teste da instrução LUI:**

Conteúdo do _.mif_ da ROM:

```asm
-- Copyright (C) 2017  Intel Corporation. All rights reserved.
-- Your use of Intel Corporation's design tools, logic functions
-- and other software and tools, and its AMPP partner logic
-- functions, and any output files from any of the foregoing
-- (including device programming or simulation files), and any
-- associated documentation or information are expressly subject
-- to the terms and conditions of the Intel Program License
-- Subscription Agreement, the Intel Quartus Prime License Agreement,
-- the Intel FPGA IP License Agreement, or other applicable license
-- agreement, including, without limitation, that your use is for
-- the sole purpose of programming logic devices manufactured by
-- Intel and sold by Intel or its authorized distributors.  Please
-- refer to the applicable agreement for further details.

WIDTH=32;
DEPTH=64;
ADDRESS_RADIX=DEC;
DATA_RADIX=HEX;

CONTENT BEGIN
      -- Valores iniciais no banco de registradores:
      -- $zero (#0) := 0x00
      -- $t0   (#8) := 0x00
      -- $t1   (#9) := 0x0A
      -- $t2  (#10) := 0x0B
      -- $t3  (#11) := 0x0C
      -- $t4  (#12) := 0x0D
      -- $t5  (#13) := 0x16

--                                                                  PC      Saida ULA
    0    :   3C080000; --lui $t0 0x0000      ($t0  := 0x00000000)   0x00    0x00000000
    1    :   35080008; --ori $t0 $t0 0x0008  ($t0  := 0x00000008)   0x04    0x00000008
    2    :   AD0A0000; --sw $t2 0($t0)       (m(8) := 0x0000000B)   0x08    0x00000008
    3    :   8D040000; --lw $a0 0($t0)       ($a0  := 0x0000000B)   0x0C    0x00000008
    4    :   00802020; --add $a0 $a0 $0      ($a0  := 0x0000000B)   0x10    0x0000000B
    5    :   3C09AA55; --lui  $t1 0xAA55     ($t1  := 0xAA550000)   0x14    0xXXXXXXXX
    6    :   31CE0001; --andi $t6 $t6 0x1    ($t6  := 0x0000000X)   0x18    0x0000000X
    7    :   35CE0001; --ori  $t6 $t6 0x1    ($t6  := 0x00000001)   0x1C    0x00000001
    8    :   012E7822; --sub  $t7 $t1 $t6    ($t7  := 0xAA54FFFF)   0x20    0xAA54FFFF
    9    :   3C09AA54; --lui  $t1 0xAA54     ($t1  := 0xAA540000)   0x24    0xXXXXXXXX
    10   :   3529FFFF; --ori  $t1 $t1 0xFFFF ($t1  := 0xAA54FFFF)   0x28    0xAA54FFFF
    11   :   012F7822; --sub  $t7 $t1 $t7    ($t7  := 0x00000000)   0x2C    0x00000000
    12   :   11E00003; --beq  $t7 $0  0x0003 ($t7  := 0x00000000)   0x30    0x00000000  se o LUI funcionar, vai para o 0x40
    13   :   08000000; --j 0x000000          (pc := #0)             0x34    0xXXXXXXXX  caso contrario, vai para 0x00
    14   :   00000000; --nop                 ($t7  := 0x00000000)   0x38    0xXXXXXXXX
    15   :   00000000; --nop                 ($t7  := 0x00000000)   0x3C    0xXXXXXXXX
    16   :   00000000; --nop                 ($t7  := 0x00000000)   0x40    0xXXXXXXXX
    17   :   00000000; --nop                 ($t7  := 0x00000000)   0x44    0xXXXXXXXX
    18   :   00000000; --nop                 ($t7  := 0x00000000)   0x48    0xXXXXXXXX
    19   :   00000000; --nop                 ($t7  := 0x00000000)   0x4C    0xXXXXXXXX
    20   :   00000000; --nop                 ($t7  := 0x00000000)   0x50    0xXXXXXXXX
    21   :   08000000; --j 0x000000          (pc := #0)             0x54    0xXXXXXXXX
   [22..62] :   00000000; --nop
    63   :   08000000; --j 0x000000          (pc := #0)             0xFC    0xXXXXXXXX
END;
```
-->
<p><br></p>
</div>
<!--- class_panel --->
<button class="accordion">
Pipeline e Subconjunto A
</button>
<div class="panel">

<p>Inicialização do Banco de Registradores em VHDL:</p>
<div class="sourceCode"><pre class="sourceCode asm"><code class="sourceCode fasm">function initMemory
        return memoria_t is variable tmp : memoria_t := (others =&gt; (others =&gt; <span class="st">&#39;0&#39;</span>))<span class="co">;</span>
  begin
        -- Inicializa os endereços:
        tmp(<span class="dv">8</span>)  := 32x<span class="st">&quot;00&quot;</span><span class="co">;  -- $t0 = 0x00</span>
        tmp(<span class="dv">9</span>)  := 32x<span class="st">&quot;0A&quot;</span><span class="co">;  -- $t1 = 0x0A</span>
        tmp(<span class="dv">10</span>) := 32x<span class="st">&quot;0B&quot;</span><span class="co">;  -- $t2 = 0x0B</span>
        tmp(<span class="dv">11</span>) := 32x<span class="st">&quot;0C&quot;</span><span class="co">;  -- $t3 = 0x0C</span>
        tmp(<span class="dv">12</span>) := 32x<span class="st">&quot;0D&quot;</span><span class="co">;  -- $t4 = 0x0D</span>
        tmp(<span class="dv">13</span>) := 32x<span class="st">&quot;16&quot;</span><span class="co">;  -- $t5 = 0x16</span>
        return tmp<span class="co">;</span>
    <span class="pp">end</span> initMemory<span class="co">;</span></code></pre></div>
<p>Conteúdo do <em>.mif</em> da ROM:</p>
<div class="sourceCode"><pre class="sourceCode asm"><code class="sourceCode fasm">      -- Valores iniciais no banco de registradores:
      -- <span class="dv">$</span>t0   (#<span class="dv">8</span>) :=<span class="bn"> 0x00</span>
      -- <span class="dv">$</span>t1   (#<span class="dv">9</span>) :=<span class="bn"> 0x0A</span>
      -- <span class="dv">$</span>t2  (#<span class="dv">10</span>) :=<span class="bn"> 0x0B</span>
      -- <span class="dv">$</span>t3  (#<span class="dv">11</span>) :=<span class="bn"> 0x0C</span>
      -- <span class="dv">$</span>t4  (#<span class="dv">12</span>) :=<span class="bn"> 0x0D</span>
      -- <span class="dv">$</span>t5  (#<span class="dv">13</span>) :=<span class="bn"> 0x16</span>

--   Programa do Single Cycle com Conjunto A, com NOPs para Rodar no Pipeline Simples:
--                                                                PC ULA    PC Exibido
      tmp(<span class="dv">0</span>) := x<span class="st">&quot;AC09_0008&quot;</span><span class="co">; --sw $t1 8($zero) (m(8) := 0x0A)      -- 0    8</span>
      tmp(<span class="dv">1</span>) := x<span class="st">&quot;8C08_0008&quot;</span><span class="co">; --lw $t0 8($zero) ($t0 := 0x0A)       -- 4    c</span>
      tmp(<span class="dv">2</span>) := x<span class="st">&quot;0000_0000&quot;</span><span class="co">;                                       -- 8    10</span>
      tmp(<span class="dv">3</span>) := x<span class="st">&quot;012A_4022&quot;</span><span class="co">; --sub $t0 $t1 $t2 ($t0 := 0xFF)       -- C    14</span>
      tmp(<span class="dv">4</span>) := x<span class="st">&quot;012A_4024&quot;</span><span class="co">; --and $t0 $t1 $t2 ($t0 := 0x0A)       -- 10   18</span>
      tmp(<span class="dv">5</span>) := x<span class="st">&quot;012A_4025&quot;</span><span class="co">; --or $t0 $t1 $t2  ($t0 := 0x0B)       -- 14   1c</span>
      tmp(<span class="dv">6</span>) := x<span class="st">&quot;012A_402A&quot;</span><span class="co">; --slt $t0 $t1 $t2 ($t0 := 0x01)       -- 18   20</span>
      tmp(<span class="dv">7</span>) := x<span class="st">&quot;0000_0000&quot;</span><span class="co">;                                       -- 1c   24</span>
      tmp(<span class="dv">8</span>) := x<span class="st">&quot;0000_0000&quot;</span><span class="co">;                                       -- 20   28</span>
      tmp(<span class="dv">9</span>) := x<span class="st">&quot;0000_0000&quot;</span><span class="co">;                                       -- 24   2c</span>
      tmp(<span class="dv">10</span>) := x<span class="st">&quot;010A_4020&quot;</span><span class="co">; --add $t0 $t0 $t2 ($t0 := 0x0C)      -- 28   30   Segunda vez: 0x17</span>
      tmp(<span class="dv">11</span>) := x<span class="st">&quot;0000_0000&quot;</span><span class="co">;                                      -- 2c   34</span>
      tmp(<span class="dv">12</span>) := x<span class="st">&quot;0000_0000&quot;</span><span class="co">;                                      -- 30   38</span>
      tmp(<span class="dv">13</span>) := x<span class="st">&quot;0000_0000&quot;</span><span class="co">;                                      -- 34   3c</span>
      tmp(<span class="dv">14</span>) := x<span class="st">&quot;110B_FFFA&quot;</span><span class="co">; --beq $t0 $t3 0xFA(pc := 0x24)       -- 38   40   &quot;FA=-6&quot;  Segunda vez: pc := 3c</span>
      tmp(<span class="dv">15</span>) := x<span class="st">&quot;0000_0000&quot;</span><span class="co">;                                      -- 3c   44</span>
      tmp(<span class="dv">16</span>) := x<span class="st">&quot;0000_0000&quot;</span><span class="co">;                                      -- 40   48</span>
      tmp(<span class="dv">17</span>) := x<span class="st">&quot;0000_0000&quot;</span><span class="co">;                                      -- 44   4c</span>
      tmp(<span class="dv">18</span>) := x<span class="st">&quot;0800_0001&quot;</span><span class="co">; --j 0x01 (pc := #1)                  -- 48   50</span>
      tmp(<span class="dv">19</span>) := x<span class="st">&quot;0000_0000&quot;</span><span class="co">;                                      -- 4c   54</span>
      tmp(<span class="dv">20</span>) := x<span class="st">&quot;0C00_001F&quot;</span><span class="co">; --jal 0x00001F                       -- pc := #31</span>
      tmp(<span class="dv">21</span>) := x<span class="st">&quot;0800_0000&quot;</span><span class="co">; --j 0x000000                         -- pc := #0</span>
      tmp(<span class="dv">31</span>) := x<span class="st">&quot;03E0_0008&quot;</span><span class="co">; --jr $ra                             -- pc := #17</span></code></pre></div>
<p>
<font style="color:red;font-weight:bold;">O valor do PC é lido na primeira etapa do pipeline (ID) e o resultado da ULA na terceira etapa (EX).<br> Por isso, os dois primeiros ciclos, enquanto não existe resultado (útil) na ULA, a saída é 0x0.<br> Essa defasagem entre o valor mostrado do PC e o resultado da ULA é mantida durante toda a execução.<br> Para facilitar, verique a execução utilizando o valor da tabela referente ao PC Exibido (7 segmentos).<br> Note que no caso do JMP, como a execução acontece no estágio ID, a mudança do valor exibido acontecerá antes do esperado. </font>
</p>
<p><br></p>
<table style="width:64%;">
<caption><strong>Resultados da Execução: Programa do Ciclo Único e Conjunto A Rodando no Pipeline Simples</strong></caption>
<colgroup>
<col width="11%" />
<col width="9%" />
<col width="8%" />
<col width="12%" />
<col width="22%" />
</colgroup>
<thead>
<tr class="header">
<th align="center">PC Exibido (7 Seg)<br>Etapa IF</th>
<th align="center">PC Programa<br>Etapa da ULA (EX)</th>
<th align="left">Saída ULA<BR>Etapa EX</th>
<th align="left">Instrução<br>Executada (EX)</th>
<th align="left">Comentário</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0x00</td>
<td align="center">0xXX</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">----</td>
<td align="left">Carregando o Pipeline</td>
</tr>
<tr class="even">
<td align="center">0x04</td>
<td align="center">0xXX</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">----</td>
<td align="left">Carregando o Pipeline</td>
</tr>
<tr class="odd">
<td align="center">0x08</td>
<td align="center">0x00</td>
<td align="left">0x00000008</td>
<td align="left">sw $t1 8($zero)</td>
<td align="left">M(8) := 0x0000000A</td>
</tr>
<tr class="even">
<td align="center">0x0C</td>
<td align="center">0x04</td>
<td align="left">0x00000008</td>
<td align="left">lw $t0 8($zero)</td>
<td align="left">$t0 := 0x0000000A</td>
</tr>
<tr class="odd">
<td align="center">0x10</td>
<td align="center">0x08</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">nop</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="center">0x14</td>
<td align="center">0x0C</td>
<td align="left">0xFFFFFFFF</td>
<td align="left">sub $t0 $t1 $t2</td>
<td align="left">$t0 := 0xFFFFFFFF</td>
</tr>
<tr class="odd">
<td align="center">0x18</td>
<td align="center">0x10</td>
<td align="left">0x0000000A</td>
<td align="left">and $t0 $t1 $t2</td>
<td align="left">$t0 := 0x0000000A</td>
</tr>
<tr class="even">
<td align="center">0x1C</td>
<td align="center">0x14</td>
<td align="left">0x0000000B</td>
<td align="left">or $t0 $t1 $t2</td>
<td align="left">$t0 := 0x0000000B</td>
</tr>
<tr class="odd">
<td align="center">0x20</td>
<td align="center">0x18</td>
<td align="left">0x00000001</td>
<td align="left">slt $t0 $t1 $t2</td>
<td align="left">$t0 := 0x00000001</td>
</tr>
<tr class="even">
<td align="center">0x24</td>
<td align="center">0x1C</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">nop</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="center">0x28</td>
<td align="center">0x20</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">nop</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="center">0x2C</td>
<td align="center">0x24</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">nop</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="center">0x30</td>
<td align="center">0x28</td>
<td align="left">0x0000000C</td>
<td align="left">add $t0 $t0 $t2</td>
<td align="left">$t0 := 0x0000000C</td>
</tr>
<tr class="even">
<td align="center">0x34</td>
<td align="center">0x2C</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">nop</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="center">0x38</td>
<td align="center">0x30</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">nop</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="center">0x3C</td>
<td align="center">0x34</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">nop</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="center">0x40</td>
<td align="center">0x38</td>
<td align="left">0x00000000</td>
<td align="left">beq $t0 $t3 0xFFFA</td>
<td align="left">FA=-6; pc := 0x24</td>
</tr>
<tr class="even">
<td align="center">0x44</td>
<td align="center">0x3C</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">nop</td>
<td align="left">Em EX no clock do BEQ</td>
</tr>
<tr class="odd">
<td align="center">0x24</td>
<td align="center">0x40</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">nop</td>
<td align="left">Em ID no clock do BEQ</td>
</tr>
<tr class="even">
<td align="center">0x28</td>
<td align="center">0x44</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">nop</td>
<td align="left">Em IF no clock do BEQ</td>
</tr>
<tr class="odd">
<td align="center">0x2C</td>
<td align="center">0x24</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">nop</td>
<td align="left">Destino do BEQ</td>
</tr>
<tr class="even">
<td align="center">0x30</td>
<td align="center">0x28</td>
<td align="left">0x00000017</td>
<td align="left">add $t0 $t0 $t2</td>
<td align="left">$t0 := 0x00000017</td>
</tr>
<tr class="odd">
<td align="center">0x34</td>
<td align="center">0x2C</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">nop</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="center">0x38</td>
<td align="center">0x30</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">nop</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="center">0x3C</td>
<td align="center">0x34</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">nop</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="center">0x40</td>
<td align="center">0x38</td>
<td align="left">0x0000000B</td>
<td align="left">beq $t0 $t3 0xFFFA</td>
<td align="left">FA=-6; pc := 0x3C</td>
</tr>
<tr class="odd">
<td align="center">0x44</td>
<td align="center">0x3C</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">nop</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="center">0x48</td>
<td align="center">0x40</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">nop</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="center">0x4C</td>
<td align="center">0x44</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">nop</td>
<td align="left">Quando este NOP chega em EX, o endereço do JMP é atualizado em ID</td>
</tr>
<tr class="even">
<td align="center">0x04</td>
<td align="center">0x48</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">j 0x000001</td>
<td align="left">pc := 0x04; <font style="color:red">JMP executado</font></td>
</tr>
<tr class="odd">
<td align="center">0x08</td>
<td align="center">0x4C</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">nop</td>
<td align="left">Em IF no clock do JMP</td>
</tr>
<tr class="even">
<td align="center">0x0C</td>
<td align="center">0x04</td>
<td align="left">0x00000008</td>
<td align="left">lw $t0 8($zero)</td>
<td align="left">$t0 := 0x0000000A</td>
</tr>
<tr class="odd">
<td align="center">60</td>
<td align="center">0x3C</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">jal 0x00001F</td>
<td align="left">&lt;&lt; 0x1F := 0x7C</td>
</tr>
<tr class="even">
<td align="center">124</td>
<td align="center">0x7C</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">jr $ra</td>
<td align="left">pc := 0x40</td>
</tr>
<tr class="odd">
<td align="center">64</td>
<td align="center">0x40</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">nop</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="center">68</td>
<td align="center">0x44</td>
<td align="left">0xXXXXXXXX</td>
<td align="left">j 0x000000</td>
<td align="left">Volta ao Início</td>
</tr>
</tbody>
</table>
<br>
<hr style="width:60%;margin: auto;">
<p><br></p>
<p><strong>Programa que será usado no teste final do Pipeline Simples e Conjunto A:</strong></p>
<p>Conteúdo do <em>.mif</em> da ROM:</p>
<div class="sourceCode"><pre class="sourceCode asm"><code class="sourceCode fasm">
-- Copyright (C) <span class="dv">2017</span>  Intel Corporation. All rights reserved.
-- Your use of Intel Corporation<span class="st">&#39;s design tools, logic functions</span>
-- <span class="bu">and</span> other software <span class="bu">and</span> tools, <span class="bu">and</span> its AMPP partner logic
-- functions, <span class="bu">and</span> any output files <span class="bu">from</span> any of the foregoing
-- (including device programming <span class="bu">or</span> simulation files), <span class="bu">and</span> any
-- associated documentation <span class="bu">or</span> information are expressly subject
-- to the terms <span class="bu">and</span> conditions of the Intel Program License
-- Subscription Agreement, the Intel Quartus Prime License Agreement,
-- the Intel FPGA IP License Agreement, <span class="bu">or</span> other applicable license
-- agreement, including, without limitation, that your use is for
-- the sole purpose of programming logic devices manufactured by
-- Intel <span class="bu">and</span> sold by Intel <span class="bu">or</span> its authorized distributors.  Please
-- refer to the applicable agreement for further details.

WIDTH=<span class="dv">32</span><span class="co">;</span>
DEPTH=<span class="dv">64</span><span class="co">;</span>
ADDRESS_RADIX=<span class="bu">DEC</span><span class="co">;</span>
DATA_RADIX=HEX<span class="co">;</span>

CONTENT BEGIN
      -- Valores iniciais no banco de registradores:
      -- <span class="dv">$</span>t0   (#<span class="dv">8</span>) :=<span class="bn"> 0x00</span>
      -- <span class="dv">$</span>t1   (#<span class="dv">9</span>) :=<span class="bn"> 0x0A</span>
      -- <span class="dv">$</span>t2  (#<span class="dv">10</span>) :=<span class="bn"> 0x0B</span>
      -- <span class="dv">$</span>t3  (#<span class="dv">11</span>) :=<span class="bn"> 0x0C</span>
      -- <span class="dv">$</span>t4  (#<span class="dv">12</span>) :=<span class="bn"> 0x0D</span>
      -- <span class="dv">$</span>t5  (#<span class="dv">13</span>) :=<span class="bn"> 0x16</span>

    <span class="dv">0</span>    :   AC090008<span class="co">; --sw $t1 8($zero)     (m(8) := 0x0000000A)</span>
    <span class="dv">1</span>    :   8C080008<span class="co">; --lw $t0 8($zero)     ($t0 := 0x0000000A)</span>
    <span class="dv">2</span>    :   012A4022<span class="co">; --sub $t0 $t1 $t2     ($t0 := 0xFFFFFFFF)</span>
    <span class="dv">3</span>    :   012A4024<span class="co">; --and $t0 $t1 $t2     ($t0 := 0x0000000A)</span>
    <span class="dv">4</span>    :   012A4025<span class="co">; --or $t0 $t1 $t2      ($t0 := 0x0000000B)</span>
    <span class="dv">5</span>    :   012A402A<span class="co">; --slt $t0 $t1 $t2     ($t0 := 0x00000001)</span>
    <span class="dv">6</span>    :   010A4020<span class="co">; --add $t0 $t0 $t2     HAZARD  ($t0 := 0x0000000A)</span>
    <span class="dv">7</span>    :   110BFFFE<span class="co">; --beq $t0 $t3 0xFFFE  HAZARD  (pc := #8)</span>
    <span class="dv">8</span>    :   0800000C<span class="co">; --j 0x00000C          HAZARD  (pc := #12)</span>
   [<span class="dv">9</span>..<span class="dv">11</span>] : <span class="dv">00000000</span><span class="co">; --nop</span>
    <span class="dv">12</span>   :   AC090008<span class="co">; --sw $t1 8($zero)     (m(8) := 0x0000000A)</span>
    <span class="dv">13</span>   :   8C080008<span class="co">; --lw $t0 8($zero)     ($t0 := 0x0000000A)</span>
    <span class="dv">14</span>   :   012A4022<span class="co">; --sub $t0 $t1 $t2     ($t0 := 0xFFFFFFFF)</span>
    <span class="dv">15</span>   :   012A4024<span class="co">; --and $t0 $t1 $t2     ($t0 := 0x0000000A)</span>
    <span class="dv">16</span>   :   012A4025<span class="co">; --or $t0 $t1 $t2      ($t0 := 0x0000000B)</span>
    <span class="dv">17</span>   :   012A402A<span class="co">; --slt $t0 $t1 $t2     ($t0 := 0x00000001)</span>
   [<span class="dv">18</span>..<span class="dv">20</span>] : <span class="dv">00000000</span><span class="co">; --nop</span>
    <span class="dv">21</span>   :   010A4020<span class="co">; --add $t0 $t0 $t2     ($t0 := 0x0000000C)</span>
                         --segunda execução: (<span class="dv">$</span>t0 := <span class="bn">0x00000017</span>)
   [<span class="dv">22</span>..<span class="dv">24</span>] : <span class="dv">00000000</span><span class="co">; --nop</span>
    <span class="dv">25</span>   :   110BFFFB<span class="co">; --beq $t0 $t3 0xFFFB  (pc := #21)</span>
                         --segunda execução: (pc := #<span class="dv">26</span>)
   [<span class="dv">26</span>..<span class="dv">27</span>] : <span class="dv">00000000</span><span class="co">; --nop</span>
    <span class="dv">28</span>   :   <span class="dv">08000000</span><span class="co">; --j 0x000000          (pc := #0)</span>
   [<span class="dv">29</span>..<span class="dv">63</span>] : <span class="dv">00000000</span><span class="co">; --nop</span>
<span class="pp">END</span><span class="co">;</span></code></pre></div>
<p><br> <!--
<p><font style="color:red;font-size:20px;font-weight:bold;">Falta acertar a tabela para o programa acima!!!!</font></p>

| PC Exibido (7 Seg)<br>Etapa IF | PC Programa<br>Etapa da ULA (EX) | Saída ULA<BR>Etapa EX | Instrução<br>Executada (EX) | Comentário |
|:-----:|:----:|:----|:-------|:----------|
| 0x00 | 0xXX | 0xXXXXXXXX | ---- | Carregando o Pipeline |
| 0x04 | 0xXX | 0xXXXXXXXX | ---- | Carregando o Pipeline |
| 0x08 | 0x00 | 0x00000008 | sw \$t1 8($zero) | M(8) := 0x0000000A |
| 0x0C | 0x04 | 0x00000008 | lw \$t0  8($zero) | $t0 := 0x0000000A |
| 0x10 | 0x08 | 0xXXXXXXXX |nop||
| 0x14 | 0x0C | 0xFFFFFFFF | sub $t0 $t1 $t2 | $t0 := 0xFFFFFFFF |
| 0x18 | 0x10 | 0x0000000A | and $t0 $t1 $t2 | $t0 := 0x0000000A |
| 0x1C | 0x14 | 0x0000000B | or $t0 $t1 $t2 | $t0 := 0x0000000B |
| 0x20 | 0x18 | 0x00000001 | slt $t0 $t1 $t2 | $t0 := 0x00000001 |
| 0x24 | 0x1C | 0xXXXXXXXX |nop||
| 0x28 | 0x20 | 0xXXXXXXXX |nop||
| 0x2C | 0x24 | 0xXXXXXXXX |nop||
| 0x30 | 0x28 | 0x0000000C | add $t0 $t0 $t2 | $t0 := 0x0000000C |
| 0x34 | 0x2C | 0xXXXXXXXX |nop||
| 0x38 | 0x30 | 0xXXXXXXXX |nop||
| 0x3C | 0x34 | 0xXXXXXXXX |nop||
| 0x40 | 0x38 | 0x00000000 | beq $t0 $t3 0xFFFA | FA=-6; pc := 0x24 |
| 0x44 | 0x3C | 0xXXXXXXXX |nop| Em EX no clock do BEQ |
| 0x24 | 0x40 | 0xXXXXXXXX |nop| Em ID no clock do BEQ |
| 0x28 | 0x44 | 0xXXXXXXXX |nop| Em IF no clock do BEQ |
| 0x2C | 0x24 | 0xXXXXXXXX |nop| Destino do BEQ |
| 0x30 | 0x28 | 0x00000017 | add $t0 $t0 $t2 | $t0 := 0x00000017 |
| 0x34 | 0x2C | 0xXXXXXXXX |nop||
| 0x38 | 0x30 | 0xXXXXXXXX |nop||
| 0x3C | 0x34 | 0xXXXXXXXX |nop||
| 0x40 | 0x38 | 0x0000000B | beq $t0 $t3 0xFFFA | FA=-6; pc := 0x3C |
| 0x44 | 0x3C | 0xXXXXXXXX |nop||
| 0x48 | 0x40 | 0xXXXXXXXX |nop||
| 0x4C | 0x44 | 0xXXXXXXXX |nop||
| 0x04 | 0x48 | 0xXXXXXXXX | j 0x000001 | pc := 0x04; JMP executa em ID |
| 0x08 | 0x4C | 0xXXXXXXXX |nop| Em IF no clock do JMP |
| 0x0C | 0x04 | 0x00000008 | lw \$t0  8($zero) | $t0 := 0x0000000A |
| 68 | 0x44 | 0xXXXXXXXX | j 0x000000 | Volta ao Início |

Table: **Resultados da Execução: Pipeline e Conjunto A**

--></p>
<p><br></p>
</div>
<!--- class_panel --->
<button class="accordion">
Pipeline e Subconjuntos A e B
</button>
<div class="panel">
<p>Conteúdo da função de inicialização da ROM, em VHDL:</p>
<div class="sourceCode"><pre class="sourceCode asm"><code class="sourceCode fasm">
  FUNCTION initMemory
    RETURN blocoMemoria IS VARIABLE tmp : blocoMemoria := (OTHERS =&gt; (OTHERS =&gt; <span class="st">&#39;0&#39;</span>))<span class="co">;</span>
  BEGIN

    -- Valores iniciais no banco de registradores
    -- <span class="dv">$</span>zero (#<span class="dv">0</span>) :=<span class="bn"> 0x00</span>
    -- <span class="dv">$</span>t0 (#<span class="dv">8</span>)  :=<span class="bn"> 0x00</span>
    -- <span class="dv">$</span>t1 (#<span class="dv">9</span>)  :=<span class="bn"> 0x0A</span>
    -- <span class="dv">$</span>t2 (#<span class="dv">10</span>) :=<span class="bn"> 0x0B</span>
    -- <span class="dv">$</span>t3 (#<span class="dv">11</span>) :=<span class="bn"> 0x0C</span>
    -- <span class="dv">$</span>t4 (#<span class="dv">12</span>) :=<span class="bn"> 0x0D</span>
    -- <span class="dv">$</span>t5 (#<span class="dv">13</span>) :=<span class="bn"> 0x16</span>

    --    -- Carga para instruções do grupo A e B pipeline:
    tmp(<span class="dv">0</span>) := x<span class="st">&quot;AC090008&quot;</span><span class="co">; --sw $t1 8($zero)     (m(8) := 0x0000000A)</span>
    tmp(<span class="dv">1</span>) := x<span class="st">&quot;8C080008&quot;</span><span class="co">; --lw $t0 8($zero)     ($t0 := 0x0000000A)</span>
    tmp(<span class="dv">2</span>) := x<span class="st">&quot;012A4022&quot;</span><span class="co">; --sub $t0 $t1 $t2     ($t0 := 0xFFFFFFFF)</span>
    tmp(<span class="dv">3</span>) := x<span class="st">&quot;012A4024&quot;</span><span class="co">; --and $t0 $t1 $t2     ($t0 := 0x0000000A)</span>
    tmp(<span class="dv">4</span>) := x<span class="st">&quot;012A4025&quot;</span><span class="co">; --or $t0 $t1 $t2      ($t0 := 0x0000000B)</span>
    tmp(<span class="dv">5</span>) := x<span class="st">&quot;3C08FFFF&quot;</span><span class="co">; --lui $x $t0 0xFFFF   ($t0 := 0xFFFF0000)</span>
    tmp(<span class="dv">6</span>) := x<span class="st">&quot;2128000A&quot;</span><span class="co">; --addi $t0 $t1 0x000A ($t0 := 0x00000014)</span>
    tmp(<span class="dv">7</span>) := x<span class="st">&quot;31080013&quot;</span><span class="co">; --andi $t0 $t0 0x0013 HAZARD  ($t0 := 0x00000002) (leu t0=A do pc=3)</span>
    tmp(<span class="dv">8</span>) := x<span class="st">&quot;35880007&quot;</span><span class="co">; --ori $t0 $t4 0x0007  ($t0 := 0x0000000F)</span>
    tmp(<span class="dv">9</span>) := x<span class="st">&quot;2928FFFF&quot;</span><span class="co">; --slti $t0 $t1 0xFFFF ($t0 := 0x00000000)</span>

    tmp(<span class="dv">10</span>) := x<span class="st">&quot;012A402A&quot;</span><span class="co">; --slt $t0 $t1 $t2     ($t0 := 0x00000001)</span>
    tmp(<span class="dv">11</span>) := x<span class="st">&quot;010A4020&quot;</span><span class="co">; --add $t0 $t0 $t2     HAZARD  ($t0 := 0x0000000D) (B + 2 leu t0 = 2 pc=7)</span>
    tmp(<span class="dv">12</span>) := x<span class="st">&quot;110BFFFE&quot;</span><span class="co">; --beq $t0 $t3 0xFFFE  HAZARD  (pc := #13, nao fez beq)</span>
    tmp(<span class="dv">13</span>) := x<span class="st">&quot;08000010&quot;</span><span class="co">; --j 0x000010          (pc := #16)</span>

    tmp(<span class="dv">16</span>) := x<span class="st">&quot;AC090008&quot;</span><span class="co">; --sw $t1 8($zero)     (m(8) := 0x0000000A)</span>
    tmp(<span class="dv">17</span>) := x<span class="st">&quot;8C080008&quot;</span><span class="co">; --lw $t0 8($zero)     ($t0 := 0x0000000A)</span>
    tmp(<span class="dv">18</span>) := x<span class="st">&quot;012A4022&quot;</span><span class="co">; --sub $t0 $t1 $t2     ($t0 := 0xFFFFFFFF)</span>
    tmp(<span class="dv">19</span>) := x<span class="st">&quot;012A4024&quot;</span><span class="co">; --and $t0 $t1 $t2     ($t0 := 0x0000000A)</span>

    tmp(<span class="dv">20</span>) := x<span class="st">&quot;012A4025&quot;</span><span class="co">; --or $t0 $t1 $t2      ($t0 := 0x0000000B)</span>
    tmp(<span class="dv">21</span>) := x<span class="st">&quot;3C08FFFF&quot;</span><span class="co">; --lui $x $t0 0xFFFF   ($t0 := 0xFFFF0000)</span>
    tmp(<span class="dv">22</span>) := x<span class="st">&quot;2128000A&quot;</span><span class="co">; --addi $t0 $t1 0x000A ($t0 := 0x00000014)</span>
    tmp(<span class="dv">26</span>) := x<span class="st">&quot;31080013&quot;</span><span class="co">; --andi $t0 $t0 0x0013 ($t0 := 0x00000010)</span>
    tmp(<span class="dv">27</span>) := x<span class="st">&quot;35880007&quot;</span><span class="co">; --ori $t0 $t4 0x0007  ($t0 := 0x0000000F)</span>
    tmp(<span class="dv">28</span>) := x<span class="st">&quot;2928FFFF&quot;</span><span class="co">; --slti $t0 $t1 0xFFFF ($t0 := 0x00000000)</span>

    tmp(<span class="dv">32</span>) := x<span class="st">&quot;010A4020&quot;</span><span class="co">; --add $t0 $t0 $t2     ($t0 := 0x0000000B)</span>
    --segunda execução:      (<span class="dv">$</span>t0 := <span class="bn">0x00000016</span>)
    tmp(<span class="dv">36</span>) := x<span class="st">&quot;150DFFFB&quot;</span><span class="co">; --bne $t0 $t5 0xFFFB  (pc := #32)</span>
    --segunda execução:      (pc := #<span class="dv">37</span>)
    tmp(<span class="dv">40</span>) := x<span class="st">&quot;012A402A&quot;</span><span class="co">; --slt $t0 $t1 $t2     ($t0 := 0x00000001)</span>

    tmp(<span class="dv">44</span>) := x<span class="st">&quot;010A4020&quot;</span><span class="co">; --add $t0 $t0 $t2     ($t0 := 0x0000000C)</span>
    --segunda execução:      (<span class="dv">$</span>t0 := <span class="bn">0x00000017</span>)
    tmp(<span class="dv">48</span>) := x<span class="st">&quot;110BFFFB&quot;</span><span class="co">; --beq $t0 $t3 0xFFFB  (pc := #44)</span>
    --segunda execução:      (pc := #<span class="dv">49</span>)
    tmp(<span class="dv">51</span>) := x<span class="st">&quot;0C00003A&quot;</span><span class="co">; --jal 0x00003A        (pc := #58)</span>
    tmp(<span class="dv">52</span>) := x<span class="st">&quot;00000000&quot;</span><span class="co">; --nop</span>
    tmp(<span class="dv">53</span>) := x<span class="st">&quot;08000000&quot;</span><span class="co">; --j 0x000000          (pc := #0)</span>
    tmp(<span class="dv">54</span>) := x<span class="st">&quot;00000000&quot;</span><span class="co">; --nop</span>

    tmp(<span class="dv">60</span>) := x<span class="st">&quot;03E00008&quot;</span><span class="co">; --jr $ra              (pc := #53)</span>
    RETURN tmp<span class="co">;</span>
  <span class="pp">END</span> initMemory<span class="co">;</span>
</code></pre></div>
<div class="sourceCode"><pre class="sourceCode asm"><code class="sourceCode fasm">
-- Copyright (C) <span class="dv">2017</span>  Intel Corporation. All rights reserved.
-- Your use of Intel Corporation<span class="st">&#39;s design tools, logic functions</span>
-- <span class="bu">and</span> other software <span class="bu">and</span> tools, <span class="bu">and</span> its AMPP partner logic
-- functions, <span class="bu">and</span> any output files <span class="bu">from</span> any of the foregoing
-- (including device programming <span class="bu">or</span> simulation files), <span class="bu">and</span> any
-- associated documentation <span class="bu">or</span> information are expressly subject
-- to the terms <span class="bu">and</span> conditions of the Intel Program License
-- Subscription Agreement, the Intel Quartus Prime License Agreement,
-- the Intel FPGA IP License Agreement, <span class="bu">or</span> other applicable license
-- agreement, including, without limitation, that your use is for
-- the sole purpose of programming logic devices manufactured by
-- Intel <span class="bu">and</span> sold by Intel <span class="bu">or</span> its authorized distributors.  Please
-- refer to the applicable agreement for further details.

WIDTH=<span class="dv">32</span><span class="co">;</span>
DEPTH=<span class="dv">64</span><span class="co">;</span>
ADDRESS_RADIX=<span class="bu">DEC</span><span class="co">;</span>
DATA_RADIX=HEX<span class="co">;</span>

CONTENT BEGIN
      -- Valores iniciais no banco de registradores:
      -- <span class="dv">$</span>t0   (#<span class="dv">8</span>) :=<span class="bn"> 0x00</span>
      -- <span class="dv">$</span>t1   (#<span class="dv">9</span>) :=<span class="bn"> 0x0A</span>
      -- <span class="dv">$</span>t2  (#<span class="dv">10</span>) :=<span class="bn"> 0x0B</span>
      -- <span class="dv">$</span>t3  (#<span class="dv">11</span>) :=<span class="bn"> 0x0C</span>
      -- <span class="dv">$</span>t4  (#<span class="dv">12</span>) :=<span class="bn"> 0x0D</span>
      -- <span class="dv">$</span>t5  (#<span class="dv">13</span>) :=<span class="bn"> 0x16</span>

    --    -- Carga para instruções do grupo A e B pipeline:
    tmp(<span class="dv">0</span>) := x<span class="st">&quot;AC090008&quot;</span><span class="co">; --sw $t1 8($zero)     (m(8) := 0x0000000A)   ULA (lixo) = 0xX</span>
    tmp(<span class="dv">1</span>) := x<span class="st">&quot;8C080008&quot;</span><span class="co">; --lw $t0 8($zero)     ($t0 := 0x0000000A)    ULA (lixo) = 0xX</span>
    tmp(<span class="dv">2</span>) := x<span class="st">&quot;012A4022&quot;</span><span class="co">; --sub $t0 $t1 $t2     ($t0 := 0xFFFFFFFF)    ULA (sw) = 0x8</span>
    tmp(<span class="dv">3</span>) := x<span class="st">&quot;012A4024&quot;</span><span class="co">; --and $t0 $t1 $t2     ($t0 := 0x0000000A)    ULA (lw) = 0x8</span>
    tmp(<span class="dv">4</span>) := x<span class="st">&quot;012A4025&quot;</span><span class="co">; --or $t0 $t1 $t2      ($t0 := 0x0000000B)    ULA (sub) = 0xFFFFFFFF</span>
    tmp(<span class="dv">5</span>) := x<span class="st">&quot;3C08FFFF&quot;</span><span class="co">; --lui $x $t0 0xFFFF   ($t0 := 0xFFFF0000)    ULA (and) = 0x0A</span>
    tmp(<span class="dv">6</span>) := x<span class="st">&quot;2128000A&quot;</span><span class="co">; --addi $t0 $t1 0x000A ($t0 := 0x00000014)    ULA (or) = 0x0B</span>
    tmp(<span class="dv">7</span>) := x<span class="st">&quot;31080013&quot;</span><span class="co">; --andi $t0 $t0 0x0013 HAZARD  ($t0 := 0x00000002) (leu t0=A do pc=3)  ULA (lui) = 0xFFFF0000 ou 0xXXXXXXXX</span>
    tmp(<span class="dv">8</span>) := x<span class="st">&quot;35880007&quot;</span><span class="co">; --ori $t0 $t4 0x0007  ($t0 := 0x0000000F)    ULA (addi) = 0x014 (resultado do addi)</span>
    tmp(<span class="dv">9</span>) := x<span class="st">&quot;2928FFFF&quot;</span><span class="co">; --slti $t0 $t1 0xFFFF ($t0 := 0x00000000)    ULA (andi) = 0x02  (resultado do andi, deveria ser 14 and 13 = 0x10)</span>

    tmp(<span class="dv">10</span>) := x<span class="st">&quot;012A402A&quot;</span><span class="co">; --slt $t0 $t1 $t2     ($t0 := 0x00000001)   ULA (ori) = 0x0F (ori 0x0d 0x07)</span>
    tmp(<span class="dv">11</span>) := x<span class="st">&quot;010A4020&quot;</span><span class="co">; --add $t0 $t0 $t2     HAZARD  ($t0 := 0x0000000D) (B + 2 leu t0 = 2 pc=7)  ULA (slti) = 0x00</span>
    tmp(<span class="dv">12</span>) := x<span class="st">&quot;110BFFFE&quot;</span><span class="co">; --beq $t0 $t3 0xFFFE  HAZARD  (pc := #13, nao fez beq)  ULA (slt) = 0x01</span>
    tmp(<span class="dv">13</span>) := x<span class="st">&quot;08000010&quot;</span><span class="co">; --j 0x000010          (pc := #16 = addr 0x40)           ULA (add) = 0x0D</span>
    [<span class="dv">14</span>..<span class="dv">15</span>]:=<span class="bn"> 0x0                                                                  </span>ULA (beq) =<span class="bn"> 0x03 </span>(t0 (ori) =<span class="bn"> 0x0F  </span>t3 = <span class="bn">0x0C</span>)
    tmp(<span class="dv">16</span>) := x<span class="st">&quot;AC090008&quot;</span><span class="co">; --sw $t1 8($zero)     (m(8) := 0x0000000A)    ULA (j) = 0x00</span>
    tmp(<span class="dv">17</span>) := x<span class="st">&quot;8C080008&quot;</span><span class="co">; --lw $t0 8($zero)     ($t0 := 0x0000000A)     ULA (nop) = 0x00</span>
    tmp(<span class="dv">18</span>) := x<span class="st">&quot;012A4022&quot;</span><span class="co">; --sub $t0 $t1 $t2     ($t0 := 0xFFFFFFFF)     ULA (sw) = 0x08</span>
    tmp(<span class="dv">19</span>) := x<span class="st">&quot;012A4024&quot;</span><span class="co">; --and $t0 $t1 $t2     ($t0 := 0x0000000A)     ULA (lw) = 0x08</span>
    tmp(<span class="dv">20</span>) := x<span class="st">&quot;012A4025&quot;</span><span class="co">; --or $t0 $t1 $t2      ($t0 := 0x0000000B)     ULA (sub) = 0xFFFFFFFF</span>
    tmp(<span class="dv">21</span>) := x<span class="st">&quot;3C08FFFF&quot;</span><span class="co">; --lui $x $t0 0xFFFF   ($t0 := 0xFFFF0000)     ULA (and) = 0x0A</span>
    tmp(<span class="dv">22</span>) := x<span class="st">&quot;2128000A&quot;</span><span class="co">; --addi $t0 $t1 0x000A ($t0 := 0x00000014)     ULA (or) = 0x0B</span>
    tmp(<span class="dv">23</span>) := <span class="bu">nop</span>                                                        ULA (lui) = <span class="bn">0xFFFF0000</span>
    tmp(<span class="dv">24</span>) := <span class="bu">nop</span>                                                        ULA (addi) =<span class="bn"> 0x14</span>
    tmp(<span class="dv">25</span>) := <span class="bu">nop</span>                                                        ULA (<span class="bu">nop</span>) =<span class="bn"> 0x00</span>
    tmp(<span class="dv">26</span>) := x<span class="st">&quot;31080013&quot;</span><span class="co">; --andi $t0 $t0 0x0013 ($t0 := 0x00000010)     ULA (nop) = 0x00</span>
    tmp(<span class="dv">27</span>) := x<span class="st">&quot;35880007&quot;</span><span class="co">; --ori $t0 $t4 0x0007  ($t0 := 0x0000000F)     ULA (nop) = 0x00</span>
    tmp(<span class="dv">28</span>) := x<span class="st">&quot;2928FFFF&quot;</span><span class="co">; --slti $t0 $t1 0xFFFF ($t0 := 0x00000000)     ULA (andi) = 0x10</span>
    tmp(<span class="dv">29</span>) := <span class="bu">nop</span>                                                        ULA (ori) =<span class="bn"> 0x0F</span>
    tmp(<span class="dv">30</span>) := <span class="bu">nop</span>                                                        ULA (slti) =<span class="bn"> 0x00</span>
    tmp(<span class="dv">31</span>) := <span class="bu">nop</span>                                                        ULA (<span class="bu">nop</span>) =<span class="bn"> 0x00</span>
    tmp(<span class="dv">32</span>) := x<span class="st">&quot;010A4020&quot;</span><span class="co">; --add $t0 $t0 $t2     ($t0 := 0x0000000B)     ULA (nop) = 0x00</span>
    --segunda execução:      (<span class="dv">$</span>t0 := <span class="bn">0x00000016</span>)
    tmp(<span class="dv">33</span>) := <span class="bu">nop</span>                                                        ULA (<span class="bu">nop</span>) =<span class="bn"> 0x00</span>
    tmp(<span class="dv">34</span>) := <span class="bu">nop</span>                                                        ULA (<span class="bu">add</span>) =<span class="bn"> 0x0B</span>
    tmp(<span class="dv">35</span>) := <span class="bu">nop</span>                                                        ULA (<span class="bu">nop</span>) =<span class="bn"> 0x00</span>
    tmp(<span class="dv">36</span>) := x<span class="st">&quot;150DFFFB&quot;</span><span class="co">; --bne $t0 $t5 0xFFFB  (pc := #32)             ULA (nop) = 0x00  PC = 32 (t0=0xB t5=0x16)</span>
    --segunda execução:      (pc := #<span class="dv">37</span>)
    tmp(<span class="dv">37</span>) := <span class="bu">nop</span>                                                        ULA (<span class="bu">nop</span>) =<span class="bn"> 0x00</span>
    tmp(<span class="dv">38</span>) := <span class="bu">nop</span>                                                        ULA (bne) = <span class="bn">0xFFFFFFF5</span>
    tmp(<span class="dv">39</span>) := <span class="bu">nop</span>                                                        ULA (<span class="bu">nop</span>) =<span class="bn"> 0x00            </span>parou aqui.
    tmp(<span class="dv">40</span>) := x<span class="st">&quot;012A402A&quot;</span><span class="co">; --slt $t0 $t1 $t2     ($t0 := 0x00000001)     ULA (nop) = 0x00  t1 = 0xB  t2 = 0x0B</span>
    tmp(<span class="dv">41</span>) := <span class="bu">nop</span>                                                        ULA (<span class="bu">nop</span>) =<span class="bn"> 0x00</span>
    tmp(<span class="dv">42</span>) := <span class="bu">nop</span>                                                        ULA (slt) =<span class="bn"> 0x01</span>
    tmp(<span class="dv">43</span>) := <span class="bu">nop</span>                                                        ULA (<span class="bu">nop</span>) =<span class="bn"> 0x00</span>
    tmp(<span class="dv">44</span>) := x<span class="st">&quot;010A4020&quot;</span><span class="co">; --add $t0 $t0 $t2     ($t0 := 0x0000000C)     ULA (nop) = 0x00</span>
    --segunda execução:      (<span class="dv">$</span>t0 := <span class="bn">0x00000017</span>)
    tmp(<span class="dv">45</span>) := <span class="bu">nop</span>                                                        ULA (<span class="bu">nop</span>) =<span class="bn"> 0x00</span>
    tmp(<span class="dv">46</span>) := <span class="bu">nop</span>                                                        ULA (<span class="bu">add</span>) =<span class="bn"> 0x0C  </span>t0 =<span class="bn"> 0x01  </span>t2 =<span class="bn"> 0x0B </span>=&gt; t0 =<span class="bn">0xC</span>
    tmp(<span class="dv">47</span>) := <span class="bu">nop</span>                                                        ULA (<span class="bu">nop</span>) =<span class="bn"> 0x00</span>
    tmp(<span class="dv">48</span>) := x<span class="st">&quot;110BFFFB&quot;</span><span class="co">; --beq $t0 $t3 0xFFFB  (pc := #44)             ULA (nop) = 0x00</span>
    --segunda execução:      (pc := #<span class="dv">49</span>)
    tmp(<span class="dv">49</span>) := <span class="bu">nop</span>                                                        ULA (<span class="bu">nop</span>) =<span class="bn"> 0x00</span>
    tmp(<span class="dv">50</span>) := <span class="bu">nop</span>                                                        ULA (beq) =<span class="bn"> 0x00    </span>PC = <span class="dv">44</span>

    execução PC <span class="dv">44</span>:
    tmp(<span class="dv">44</span>) := x<span class="st">&quot;010A4020&quot;</span><span class="co">; --add $t0 $t0 $t2     ($t0 := 0x00000017)     ULA (nop) = 0x00     --segunda execução:</span>
    tmp(<span class="dv">45</span>) := <span class="bu">nop</span>                                                        ULA (<span class="bu">nop</span>) =<span class="bn"> 0x00</span>
    tmp(<span class="dv">46</span>) := <span class="bu">nop</span>                                                        ULA (<span class="bu">add</span>) =<span class="bn"> 0x0C  </span>t0 =<span class="bn"> 0x0C  </span>t2 =<span class="bn"> 0x0B </span>=&gt; t0 =<span class="bn">0x17</span>
    tmp(<span class="dv">47</span>) := x<span class="st">&quot;00000000&quot;</span><span class="co">; --nop                                         ULA (nop) = 0x00</span>
    tmp(<span class="dv">48</span>) := x<span class="st">&quot;110BFFFB&quot;</span><span class="co">; --beq $t0 $t3 0xFFFB  (pc := #44)             ULA (nop) = 0x00</span>
    tmp(<span class="dv">49</span>) := <span class="bu">nop</span>                                                        ULA (<span class="bu">nop</span>) =<span class="bn"> 0x00</span>
    tmp(<span class="dv">50</span>) := <span class="bu">nop</span>                                                        ULA (beq) =<span class="bn"> 0x00  </span>t0=<span class="bn">0x17 </span>t3=<span class="bn">0xB</span>  --segunda execução: (pc := #<span class="dv">51</span>)
    tmp(<span class="dv">51</span>) := x<span class="st">&quot;0C00003A&quot;</span><span class="co">; --jal 0x00003A        (pc := #58)             ULA (nop) = 0x00</span>
    tmp(<span class="dv">52</span>) := x<span class="st">&quot;00000000&quot;</span><span class="co">; --nop                                         ULA (nop) = 0x00  Muda o PC para 58</span>
    tmp(<span class="dv">53</span>) := x<span class="st">&quot;08000000&quot;</span><span class="co">; --j 0x000000          (pc := #0)              ULA () = 0x</span>
    tmp(<span class="dv">54</span>) := x<span class="st">&quot;00000000&quot;</span><span class="co">; --nop                                         ULA () = 0x</span>
    tmp(<span class="dv">55</span>) := x<span class="st">&quot;00000000&quot;</span><span class="co">; --nop                                         ULA () = 0x</span>
    tmp(<span class="dv">56</span>) := x<span class="st">&quot;00000000&quot;</span><span class="co">; --nop                                         ULA () = 0x</span>
    tmp(<span class="dv">57</span>) := x<span class="st">&quot;00000000&quot;</span><span class="co">; --nop                                         ULA () = 0x</span>
    tmp(<span class="dv">58</span>) := x<span class="st">&quot;00000000&quot;</span><span class="co">; --nop                                         ULA () = 0x00</span>
    tmp(<span class="dv">59</span>) := x<span class="st">&quot;00000000&quot;</span><span class="co">; --nop                                         ULA () = 0x</span>
    tmp(<span class="dv">60</span>) := x<span class="st">&quot;03E00008&quot;</span><span class="co">; --jr $ra              (pc := #53)</span>

</code></pre></div>
<!--
```asm

-- Copyright (C) 2017  Intel Corporation. All rights reserved.
-- Your use of Intel Corporation's design tools, logic functions
-- and other software and tools, and its AMPP partner logic
-- functions, and any output files from any of the foregoing
-- (including device programming or simulation files), and any
-- associated documentation or information are expressly subject
-- to the terms and conditions of the Intel Program License
-- Subscription Agreement, the Intel Quartus Prime License Agreement,
-- the Intel FPGA IP License Agreement, or other applicable license
-- agreement, including, without limitation, that your use is for
-- the sole purpose of programming logic devices manufactured by
-- Intel and sold by Intel or its authorized distributors.  Please
-- refer to the applicable agreement for further details.

WIDTH=32;
DEPTH=64;
ADDRESS_RADIX=DEC;
DATA_RADIX=HEX;

CONTENT BEGIN
      -- Valores iniciais no banco de registradores:
      -- $t0   (#8) := 0x00
      -- $t1   (#9) := 0x0A
      -- $t2  (#10) := 0x0B
      -- $t3  (#11) := 0x0C
      -- $t4  (#12) := 0x0D
      -- $t5  (#13) := 0x16

    0    :   AC090008; --sw $t1 8($zero)     (m(8) := 0x0000000A)
    1    :   8C080008; --lw $t0 8($zero)     ($t0 := 0x0000000A)
    2    :   012A4022; --sub $t0 $t1 $t2     ($t0 := 0xFFFFFFFF)
    3    :   012A4024; --and $t0 $t1 $t2     ($t0 := 0x0000000A)
    4    :   012A4025; --or $t0 $t1 $t2      ($t0 := 0x0000000B)
    5    :   3C08FFFF; --lui $x $t0 0xFFFF   ($t0 := 0xFFFF0000)
    6    :   2128000A; --addi $t1 $t0 0x000A ($t0 := 0x00000014)
    7    :   31080013; --andi $t0 $t0 0x0013 HAZARD  ($t0 := 0x00000000)
    8    :   35880007; --ori $t4 $t0 0x0007  ($t0 := 0x0000000F)
    9    :   2928FFFF; --slti $t1 $t0 0xFFFF ($t0 := 0x00000000)

    10   :   012A402A; --slt $t0 $t1 $t2     ($t0 := 0x00000001)
    11   :   010A4020; --add $t0 $t0 $t2     HAZARD  ($t0 := 0x0000000B)
    12   :   110BFFFE; --beq $t0 $t3 0xFFFE  HAZARD  (pc := #15)
    13   :   08000000; --j 0x000010          (pc := #16)
   [14..15] : 00000000; --nop
    16   :   AC090008; --sw $t1 8($zero)     (m(8) := 0x0000000A)
    17   :   8C080008; --lw $t0 8($zero)     ($t0 := 0x0000000A)
    18   :   012A4022; --sub $t0 $t1 $t2     ($t0 := 0xFFFFFFFF)
    19   :   012A4024; --and $t0 $t1 $t2     ($t0 := 0x0000000A)

    20   :   012A4025; --or $t0 $t1 $t2      ($t0 := 0x0000000B)
    21   :   3C08FFFF; --lui $x $t0 0xFFFF   ($t0 := 0xFFFF0000)
    22   :   2128000A; --addi $t1 $t0 0x000A ($t0 := 0x00000014)
   [23..25] : 00000000; --nop
    26   :   31080013; --andi $t0 $t0 0x0013 ($t0 := 0x00000010)
    27   :   35880007; --ori $t4 $t0 0x0007  ($t0 := 0x0000000F)
    28   :   2928FFFF; --slti $t1 $t0 0xFFFF ($t0 := 0x00000000)
   [29..31] : 00000000; --nop

    32   :   010A4020; --add $t0 $t0 $t2     ($t0 := 0x0000000B)
                    --segunda execução:      ($t0 := 0x00000016)
   [33..35] : 00000000; --nop
    36   :   150DFFFB; --bne $t0 $t5 0xFFFB  (pc := #32)
                    --segunda execução:      (pc := #37)
   [37..39] : 00000000; --nop

    40   :   012A402A; --slt $t0 $t1 $t2     ($t0 := 0x00000001)
   [41..43] : 00000000; --nop
    44   :   010A4020; --add $t0 $t0 $t2     ($t0 := 0x0000000C)
                    --segunda execução:      ($t0 := 0x00000017)
   [45..47] : 00000000; --nop
    48   :   110BFFFB; --beq $t0 $t3 0xFFFB  (pc := #44)
                    --segunda execução:      (pc := #49)
   [49..50] : 00000000; --nop

    51   :   0C00003C; --jal 0x00003C        (pc := #60)
    52   :   00000000; --nop
    53   :   08000000; --j 0x000000          (pc := #0)
    54   :   00000000; --nop
   [53..59] : 00000000; --nop
    60   :   03E00008; --jr $ra              (pc := #53)
   [61..63] : 00000000; --nop
END;

```
-->
<p><br></p>
<!--

<p><font style="color:red;font-size:20px;font-weight:bold;">Falta acertar a tabela para o programa acima!!!!</font></p>

| PC Dec | PC Hex |           | Saída ULA | Instrução | Comentário |
|:---------:|:--------:|:-------:|:-------------------------|:--------------|:------------------|
| 00 | 0x00 | | 0x00000008 | sw \$t1 8($zero) | M(8) := 0x0000000A |
| 04 | 0x04 | | 0x00000008 | lw \$t0  8($zero) | $t0 := 0x0000000A |
| 08 | 0x08 | | 0xFFFFFFFF | sub $t0 $t1 $t2 | $t0 := 0xFFFFFFFF |
| 12 | 0x0C | | 0x0000000A | and $t0 $t1 $t2 | $t0 := 0x0000000A |
| 16 | 0x10 | | 0x0000000B | or $t0 $t1 $t2 | $t0 := 0x0000000B |
| 20 | 0x14 | | 0xFFFF0000 | lui $t0 0xFFFF | $t0 := 0xFFFF0000 |
| 24 | 0x18 | | 0x00000014 | addi $t0 $t1 0x000A | $t0 := 0x00000014 |
| 28 | 0x1C | | 0x00000010 | andi $t0 $t0 0x0013 | $t0 := 0x00000010 |
| 32 | 0x20 | | 0x0000000F | ori $t0 $t4 0x0007 | $t0 := 0x0000000F |
| 36 | 0x24 | | 0x00000000 | slti $t0 $t1 0xFFFF | $t0 := 0x00000000 |
| 40 | 0x28 | | 0x0000000B | add $t0 $t0 $t2 | $t0 := 0x0000000B |
| 44 | 0x2C | | 0xFFFFFFF5 | bne $t0 $t5 0xFFFE | pc := 0x28 |
| 40 | 0x28 | | 0x00000016 | add $t0 $t0 $t2 | $t0 := 0x00000016 |
| 44 | 0x2C | | 0x00000000 | bne $t0 $t5 0xFFFE | pc := 0x30 |
| 48 | 0x30 | | 0x00000001 | slt $t0 $t1 $t2 | $t0 := 0x00000001 |
| 52 | 0x34 | | 0x0000000C | add $t0 $t0 $t2 | $t0 := 0x0000000C |
| 56 | 0x38 | | 0x00000000 | beq $t0 $t3 0xFFFE | pc := 0x34 |
| 52 | 0x34 | | 0x00000017 | add $t0 $t0 $t2 | $t0 := 0x00000017 |
| 56 | 0x38 | | 0x0000000B | beq $t0 $t3 0xFFFE | pc := 0x3C |
| 60 | 0x3C | | 0xXXXXXXXX | jal 0x00001F | << 0x1F := 0x7C |
| 124 | 0x7C | | 0xXXXXXXXX | jr $ra | pc := 0x40 |
| 64 | 0x40 | | 0xXXXXXXXX | nop | |
| 68 | 0x44 | | 0xXXXXXXXX | j 0x000000 | Volta ao Início |

Table: **Resultados da Execução: Pipeline e Conjunto A + B**

-->
</div>
<!--- class_panel --->
</div>
<!--- class_panelNested --->
<hr />
<p><br></p>
<hr />
<hr />
<!-- FIM -->
<script type="text/javascript" src="../js/acordeon.js"></script>
<!---
######### (inicio dos links) ##########
--->
</body>
</html>
