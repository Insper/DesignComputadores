<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>_instrucoesDLX</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
  /* fundo para o trecho de código */
  div.sourceCode { overflow-x: auto; background-color: rgb(245,245,245);}  /*rgb(250,250,250)*/
  body {font-family: "Lato", sans-serif;}
  
  /* Para dividir a pagina em duas colunas */
   .column {
    float: left;
    width:49%;
    justify-content: center;
    align-items: center;
  }
  
  /* Clear floats after the columns */
  .row:after {
    content: "";
    display: table;
    clear: both;
  }
  
  /* Inicio do menu tipo acordeon */
  .accordion{
    background-color: #eee;
    color: #444;
    cursor: pointer;
    padding: 18px;
    width: 100%;
    border: none;
    text-align: left;
    outline: none;
    font-size: 15px;
    transition: 0.4s;
    font-weight: bold;
  }
  .active, .accordion:hover {
    background-color: #a4b8b6;
  }
  .panel {
    /*Versao anterior do accordion usa  max-height: 0 para fazer a transition e nao aceita aninhamento de acordeon*/
    padding: 0 10px;
    background-color: #f9f9f9;
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.2s ease-out;
    margin-left: 0%;
  }
  .panel p {
    margin-left: 1%;
  }
  /*Inicio do Acordeon Aninhado*/
  button.accordionNested{
    background-color: #eee;
    color: #444;
    cursor: pointer;
    padding: 18px;
    width: 100%;
    border: none;
    text-align: left;
    outline: none;
    font-size: 15px;
    font-weight: bold;
  }
  .activeNested, .accordionNested:hover {
    background-color: #a4b8b6;
  }
  .panelNested {
    /*Aceita aninhamento mas nao faz transition*/
    padding: 0 10px;
    background-color: #f9f9f9;
    display: none;
    overflow: hidden;
    margin-left: 0%;
  }
  .panelNested p {
    margin-left: 1%;
  }
  /*Inicio do Segundo Acordeon Aninhado*/
  button.accordionNestedTwo{
    background-color: #eee;
    color: #444;
    cursor: pointer;
    padding: 18px;
    width: 100%;
    border: none;
    text-align: left;
    outline: none;
    font-size: 15px;
    font-weight: bold;
  }
  .activeNestedTwo, .accordionNestedTwo:hover {
    background-color: #a4b8b6;
  }
  .panelNestedTwo {
    /*Aceita aninhamento mas nao faz transition*/
    padding: 0 10px;
    background-color: #f9f9f9;
    display: none;
    overflow: hidden;
    margin-left: 0%;
  }
  .panelNestedTwo p {
    margin-left: 1%;
  }
  /* Fim do menu tipo acordeon */
  
  .bloco .title {
      display: block;
  }
  
  /*Bloco de solucao de exercicio*/
  .bloco .label,
  .bloco .separator {
      font-weight: bold;
  }
  
  .bloco .separator {
      margin-right: .6em;
  /*    margin-left: .6em;  */
  }
  /* Solução */
  div.solucao {
    border-left: .3em solid #dd4444;   /*#dc3c01; */
    margin-left: -.8em;
    padding-left: .4em;
    position: relative;
    font-size: 90%;
  }
  
  div.solucao .conteudo {
    display: none;
    padding-top: 1px;
  }
  
  div.solucao button {
    color: #0000AF;
    background-color: white;
    border-radius: 5px;
  }
  
  div.solucao button.viewed {
    color: #FF2020;
    background-color: white;
    border-radius: 5px;
  }
  
  div.exemplo {
    /*background-color: lightgray;*/
    margin-left: 5%;
    margin-right: 5%;
  }
  
  div.exemplo .sourceCode  {
    /*background-color: lightgray;*/
    margin-left: 2%;
    margin-right: 2%;
  }
  
  div.adicional {
    margin-left: 1%;
  }
  /* Alinhamento dos títulos e parágrafos */
  
  body{margin-left: 5%; margin-right: 5%;
           color: black; background-color: #f9f9f9;}
  
  hr{
      margin-left: -4%;
      background-color: rgb(0,150,150);  /*anterior:    240,240,240 */
  }
  h1{
      margin-left: -4%;
      /*background-color: rgb(210,210,220);*/
  }
  
  h2{
      margin-left: -4%;
      /*background-color: rgb(220,220,230);*/
  }
  
  h3{
      margin-left: 0%;  /*-4%;*/
      /*background-color: rgb(230,230,240);*/
  }
  
  h4{
      margin-left: 0%;  /*-4%;*/
      /*background-color: rgb(240,240,250);*/
  }
  h5{
      margin-left: 0%;  /*-4%;*/
      /*background-color: rgb(245,245,250);*/
  }
  
  /* Cores */
  i{color: red}
  em{color: green}
  cite{color: brown}
  /* blockquote > p { */
  blockquote{color: red}
  blockquote p {
    margin-bottom: 0;
    font-size: 14px;
    font-weight: 300;
    line-height: 2em;
  }
  
  /* ---- Front Matter ----
  Pandoc header DIV. Contains .title, .author and .date. Comes before div#TOC.
  Only appears if one of those three are in the document.   */
  
  div#header, header
      {
      /* Put border on bottom. Separates it from TOC or body that comes after it. */
      border-bottom: 1px solid #aaa;
      margin-bottom: 0.5em;
      }
  
  .title /* Pandoc title header (h1.title) */
      {
      text-align: center;
      }
  
  .author, .date /* Pandoc author(s) and date headers (h2.author and h3.date) */
      {
      text-align: center;
      }
  
  /* Pandoc table of contents DIV when using the --toc option.
     NOTE: this doesn't support Pandoc's --id-prefix option for #TOC and #header.
     Probably would need to use div[id$='TOC'] and div[id$='header'] as selectors.
  */
  
  div#TOC, nav#TOC
      {
      /* Put border on bottom to separate it from body. */
  /*    border-bottom: 1px solid #aaa;   */
      margin-bottom: 0.5em;
      }
  
  @media print
      {
      div#TOC, nav#TOC
          {
          /* Don't display TOC in print */
          display: none;
          }
      }
  /* ---- Images ---- */
  img {
      /* Let it be inline left/right where it wants to be, but verticality make
         it in the middle to look nicer, but opinions differ, and if in a multi-line
         paragraph, it might not be so great.
         vertical-align: middle;
      */
      vertical-align: middle;
      max-width: 600px;
      height:auto;
      }
  div.figure /* Pandoc figure-style image */
      {
      /* Center the image and caption */
      margin-left: auto;
      margin-right: auto;
      text-align: center;
      font-style: italic;
      max-width: 600px;
      height:auto;
      }
  p.caption /* Pandoc figure-style caption within div.figure */
      {
      /* Inherits div.figure props by default */
      }
  /* ---- Tables ---- */
  table {
      margin-left: auto;
      margin-right: auto;
      margin-bottom: 24px;
      border-spacing: 0;
      border-bottom: 2px solid black;
      border-top: 2px solid black;
  }
  table th {
      padding: 3px 10px;
      background-color: white;
      border-top: 1px;
      border-left: 1px;
      border-right: 1px;
      border-bottom: 1px solid black;
  }
  table td {
      padding: 3px 10px;
      border-top: 1px;
      border-left: 1px;
      border-bottom: 1px;
      border-right: 1px;
  }
  /* fundo para as linhas das tabelas */
  tr.even{
    background-color: rgb(230,230,240);
  }
  tr.odd{
    background-color: rgb(250,250,250);
  }
  </style>
  
  
  <script type="text/javascript">
      function exibe(e)
      {
          var div = e.parentNode.firstElementChild;
          var nome = e.parentNode.id;
          var tipo=nome.substring(0, 3).toUpperCase()
          switch (tipo) {
            case "SOL":
                nome = "Solução";
                break;
            case "COD":
                nome = "Código";
                break;
            case "DIC":
                nome = "Dica";
                break;
            case "DIA":
                nome = "Diagrama";
                break;
            case "RES":
                nome = "Resumo";
                break;
            case "CON":
                nome = "Conteúdo";
                break;
            default:
                nome = "";
            }
  
          if (div.style.display == "" || div.style.display == "none") {
              div.style.display = "block";
              e.setAttribute("class", "viewed");
              e.innerHTML = "Esconder ";
          } else {
              div.style.display = "none";
              e.innerHTML = "Exibir "+nome;
          }
      }
      function validaBinario(nome) {
          var valor, tamanho, i;
          document.getElementById(nome).style.color = "black";
          valor = document.getElementById(nome).value;
          tamanho=valor.length;
          for (i=0;i<tamanho; i=i+1){
              if ( valor[i] != 1 && valor[i] != 0 ){
                  document.getElementById(nome).style.color = "red";
              }
          }
      }
  </script>
</head>
<body>
<p><a name="inicio"></a></p>
<h1 id="descrição-das-instruções-a-implementar-opção-a">Descrição das Instruções a Implementar (opção A)</h1>
<p>Ir para o <a href="#fimDocumento">fim do documento</a> e referências.</p>
<h2 id="instruções-de-referência-à-memória">Instruções de Referência à Memória</h2>
<h3 id="carrega-palavra-load-word-lw">Carrega palavra (<em>load word: lw</em>)</h3>
<p>Carrega um registrador, determinado na instrução ($t), com a palavra localizada na posição de memória que é o resultado da soma do conteúdo do segundo registrador (também definido na instrução: $s) e o valor imediato. O imediato possui 16 bits.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Instrução</th>
<th style="text-align: center;">Formato</th>
<th style="text-align: center;">Opcode/Funct</th>
<th style="text-align: center;">Operação (sintaxe estilo C)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">lw $t, imediato($s)</td>
<td style="text-align: center;">I</td>
<td style="text-align: center;">0x23 / NA</td>
<td style="text-align: center;">$t = MEM[endereço]; PC += 4;</td>
</tr>
</tbody>
</table>
<p>O valor do endereço é dado pela soma de dois inteiros de 32 bits:</p>
<ul>
<li><p>O primeiro, chamado de base, é o conteúdo do registrador definido na instrução ($s);</p></li>
<li><p>E o segundo, chamado de deslocamento, é gerado pela extensão do sinal do campo imediato (que é de 16 bits).</p></li>
</ul>
<p>A extensão do sinal do valor imediato, cria um valor de 32 bits, onde:</p>
<ul>
<li><p>Os 16 bits mais significativos (31~16) = {imediato[15]}. Ou seja, repete 16 vezes o valor do bit 15 do valor imediato;</p></li>
<li><p>Os 16 bits menos significativos (15~0) = imediato. Ou seja, o próprio imediato.</p></li>
</ul>
<p>O seja, o endereço é a soma do conteúdo do registrador com o seguinte agregado:</p>
<ul>
<li>endereço = ( R[$s] + {16{imediato[15]}, imediato} ).</li>
</ul>
<h3 id="armazena-palavra-store-word-sw">Armazena palavra (<em>store word: sw</em>)</h3>
<p>Armazena o conteúdo de um registrador, definido na instrução ($t), na posição de memória determinada pela soma do conteúdo de um segundo registrador (também definido na instrução: $s) com o valor imediato. O imediato possui 16 bits.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Instrução</th>
<th style="text-align: center;">Formato</th>
<th style="text-align: center;">Opcode/Funct</th>
<th style="text-align: center;">Operação (sintaxe estilo C)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">sw $t, imediato($s)</td>
<td style="text-align: center;">I</td>
<td style="text-align: center;">0x2B / NA</td>
<td style="text-align: center;">MEM[endereço] = $t; PC += 4;</td>
</tr>
</tbody>
</table>
<p>O valor do endereço é dado pela soma de dois inteiros de 32 bits:</p>
<ul>
<li><p>O primeiro, chamado de base, é o conteúdo do registrador definido na instrução ($s);</p></li>
<li><p>E o segundo, chamado de deslocamento, é gerado pela extensão do sinal do campo imediato (que é de 16 bits).</p></li>
</ul>
<p>A extensão do sinal do valor imediato, cria um valor de 32 bits, onde:</p>
<ul>
<li><p>Os 16 bits mais significativos (31~16) = {imediato[15]}. Ou seja, repete 16 vezes o valor do bit 15 do valor imediato;</p></li>
<li><p>Os 16 bits menos significativos (15~0) = imediato. Ou seja, o próprio imediato.</p></li>
</ul>
<p>O seja, o endereço é a soma do conteúdo do registrador com o seguinte agregado:</p>
<ul>
<li>endereço = ( R[$s] + {16{imediato[15]}, imediato} ).</li>
</ul>
<hr />
<p><br></p>
<h2 id="instruções-lógicas-e-aritméticas">Instruções Lógicas e Aritméticas</h2>
<h3 id="soma-add">Soma (<em>add</em>)</h3>
<p>Soma o conteúdo de dois registradores, definidos na instrução, e armazena o resultado em um terceiro registrador (também definido na instrução), que pode, ou não, ser um dos dois anteriores.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Instrução</th>
<th style="text-align: center;">Formato</th>
<th style="text-align: center;">Opcode/Funct</th>
<th style="text-align: center;">Operação (sintaxe estilo C)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">add $d, $s, $t</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">0x0 / 0x20</td>
<td style="text-align: center;">$d = $s + $t; PC += 4;</td>
</tr>
</tbody>
</table>
<h3 id="subtração-sub">Subtração (<em>sub</em>)</h3>
<p>Faz a subtração entre o conteúdo de dois registradores, definidos na instrução, e armazena o resultado em um terceiro registrador (também definido na instrução), que pode, ou não, ser um dos dois anteriores.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Instrução</th>
<th style="text-align: center;">Formato</th>
<th style="text-align: center;">Opcode/Funct</th>
<th style="text-align: center;">Operação (sintaxe estilo C)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">sub $d, $s, $t</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">0x0 / 0x22</td>
<td style="text-align: center;">$d = $s - $t; PC += 4;</td>
</tr>
</tbody>
</table>
<h3 id="e-lógico-and">E lógico (<em>and</em>)</h3>
<p>Executa a operação lógica “E”, bit a bit, entre o conteúdo de dois registradores, definidos na instrução, e armazena o resultado em um terceiro registrador (também definido na instrução), que pode, ou não, ser um dos dois anteriores.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Instrução</th>
<th style="text-align: center;">Formato</th>
<th style="text-align: center;">Opcode/Funct</th>
<th style="text-align: center;">Operação (sintaxe estilo C)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">and $d, $s, $t</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">0x0 / 0x24</td>
<td style="text-align: center;">$d = $s &amp; $t; PC += 4;</td>
</tr>
</tbody>
</table>
<h3 id="ou-lógico-or">OU lógico (<em>or</em>)</h3>
<p>Executa a operação lógica “OU”, bit a bit, entre o conteúdo de dois registradores, definidos na instrução, e armazena o resultado em um terceiro registrador (também definido na instrução), que pode, ou não, ser um dos dois anteriores.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Instrução</th>
<th style="text-align: center;">Formato</th>
<th style="text-align: center;">Opcode/Funct</th>
<th style="text-align: center;">Operação (sintaxe estilo C)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">or $d, $s, $t</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">0x0 / 0x25</td>
<td style="text-align: center;">$d = $s | $t; PC += 4;</td>
</tr>
</tbody>
</table>
<h3 id="comparação-menor-que-set-if-less-than-slt">Comparação Menor Que (<em>set if less than: slt</em>)</h3>
<p>Compara o conteúdo de dois registradores (definidos na instrução) e indica o resultado em um terceiro registrador (também definido na instrução). Usando o exemplo da tabela abaixo, se o conteúdo do registrador $s for menor que o conteúdo do registrador $t, o registrador $d recebe o valor 1. Caso contrário, $d recebe o valor 0.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Instrução</th>
<th style="text-align: center;">Formato</th>
<th style="text-align: center;">Opcode/Funct</th>
<th style="text-align: center;">Operação (sintaxe estilo C)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">slt $d, $s, $t</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">0x0 / 0x2A</td>
<td style="text-align: center;">$d = ($s &lt; $t ? 1: 0); PC += 4;</td>
</tr>
</tbody>
</table>
<p>Os registradores comparados contém inteiros com sinal.</p>
<hr />
<p><br></p>
<h2 id="instruções-de-desvio">Instruções de Desvio</h2>
<h3 id="desvia-se-igual-branch-equal-beq">Desvia Se Igual (<em>branch equal: beq</em>)</h3>
<p>Compara o conteúdo de dois registradores definidos na instrução. Se forem iguais, desvia para o endereço definido por (PC+4)+(extSinal(imediato &lt;&lt; 2)). Caso contrário, continua na próxima instrução.</p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Instrução</th>
<th style="text-align: center;">Formato</th>
<th style="text-align: center;">Opcode/Funct</th>
<th style="text-align: center;">Operação (sintaxe estilo C)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">beq $s, $t, imediato</td>
<td style="text-align: center;">I</td>
<td style="text-align: center;">0x04 / NA</td>
<td style="text-align: center;">if($s == $t) PC += 4 + (Imediato &lt;&lt; 2) else PC += 4;</td>
</tr>
</tbody>
</table>
<p>Ou seja, o endereço de desvio é a soma do PC+4 e do agregado:</p>
<ul>
<li>endereço = (PC + 4) + ({14{imediato[15]}, imediato, 0, 0}).</li>
</ul>
<h3 id="salto-incondicional-jump-j">Salto incondicional (<em>jump: j</em>)</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Instrução</th>
<th style="text-align: center;">Formato</th>
<th style="text-align: center;">Opcode/Funct</th>
<th style="text-align: center;">Operação (sintaxe estilo C)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">j valor</td>
<td style="text-align: center;">J</td>
<td style="text-align: center;">0x02 / NA</td>
<td style="text-align: center;">PC = destino;</td>
</tr>
</tbody>
</table>
<p>O valor de destino é calculado da através do seguinte agregado:</p>
<ul>
<li>destino = {(PC+4)[31:28] , valor, 0, 0}</li>
</ul>
<p>Ou seja, os quatro bits mais significativos do PC+4, concatenado com os 26 bits do campo valor, concatenado com dois bits com o valor 0.</p>
<hr />
<p><br></p>
<h2 id="formato-das-instruções">Formato das Instruções</h2>
<p><strong>Tipo R:</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Formato</th>
<th style="text-align: center;">Bits:</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">31 ~ 26</td>
<td style="text-align: center;">25 ~ 21</td>
<td style="text-align: center;">20 ~ 16</td>
<td style="text-align: center;">15 ~ 11</td>
<td style="text-align: center;">10 ~ 6</td>
<td style="text-align: center;">5 ~ 0</td>
</tr>
<tr class="even">
<td style="text-align: center;">tipo R</td>
<td style="text-align: center;">0x0</td>
<td style="text-align: center;">Rs</td>
<td style="text-align: center;">Rt</td>
<td style="text-align: center;">Rd</td>
<td style="text-align: center;">sem uso</td>
<td style="text-align: center;">funct</td>
</tr>
</tbody>
</table>
<p><br></p>
<p><strong>Tipo I:</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Formato</th>
<th style="text-align: center;">Bits:</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">31 ~ 26</td>
<td style="text-align: center;">25 ~ 21</td>
<td style="text-align: center;">20 ~ 16</td>
<td style="text-align: center;">15 ~ 0</td>
</tr>
<tr class="even">
<td style="text-align: center;">tipo I</td>
<td style="text-align: center;">opcode</td>
<td style="text-align: center;">Rs</td>
<td style="text-align: center;">Rd</td>
<td style="text-align: center;">valor imediato (16 bits)</td>
</tr>
</tbody>
</table>
<p><br></p>
<p><strong>Tipo J:</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Formato</th>
<th style="text-align: center;">Bits:</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">31 ~ 26</td>
<td style="text-align: center;">25 ~ 0</td>
</tr>
<tr class="even">
<td style="text-align: center;">tipo J</td>
<td style="text-align: center;">opcode</td>
<td style="text-align: center;">valor imediato (26 bits)</td>
</tr>
</tbody>
</table>
<p><br></p>
<hr />
<h1 id="instruções-a-implementar-opção-b">Instruções a Implementar (opção B)</h1>
<h2 id="instruções">Instruções</h2>
<p>O <strong>subconjunto “B”</strong> possui as instruções do subconjunto “A” e adiciona as listadas abaixo:</p>
<ul>
<li><p>A instrução de carga:</p>
<ul>
<li>Carrega imediato para 16 bits MSB (<em>load upper immediate: lui</em>).</li>
</ul></li>
<li><p>As instruções lógico-aritméticas:</p>
<ul>
<li><p>Soma com imediato (<em>addi</em>);</p></li>
<li><p>E lógico com imediato (<em>ANDI</em>);</p></li>
<li><p>OU lógico com imediato (<em>ORI</em>);</p></li>
<li><p>Comparação menor que imediato (<em>set if less than: slti</em>).</p></li>
</ul></li>
<li><p>As instruções de desvio:</p>
<ul>
<li><p>Desvio se não igual (<em>branch not equal: bne</em>);</p></li>
<li><p>Salto e conecta (<em>jump and link: jal</em>);</p></li>
<li><p>Salto por registrador (<em>jump register: jr</em>).</p></li>
</ul></li>
</ul>
<h3 id="funcionamento">Funcionamento</h3>
<p>Cabe ao aluno pesquisar o funcionamento dessas instruções.</p>
<hr />
<p><br></p>
<p><a name="fimDocumento"></a> <a href="#inicio">Ir para o início do documento</a>.</p>
<hr />
<p><br></p>
<hr />
<hr />
<!-- FIM -->
<!---
######### (inicio dos links) ##########
--->
<!--
# Modos de Endereçamento

Registrador:

Sintaxe: load r1, r2;

Semântica: r1 ← (Reg2);

Imediato (16 bits ou 26 bits, depende da instrução):

Sintaxe:  load r1, #const

Semântica:  r1 ← const;

Indireto por registrador:

Sintaxe: load r1, (r2)

Semântica: r1 ← Mem \[(r2)];

Deslocamento (16 bits):

Sintaxe: r1, deslocamento (Reg2);

Semântica: r1 ← Mem\[deslocamento + (Reg2)]

Relativo ao PC (contador de programa):

Sintaxe:  branch deslocamento;

Semântica: PC ←  PC + step + deslocamento (if branch taken)
-->
</body>
</html>
