<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Aula-02</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style>
  /* fundo para o trecho de código */
  div.sourceCode { overflow-x: auto; background-color: rgb(245,245,245);}  /*rgb(250,250,250)*/
  body {font-family: "Lato", sans-serif;}
  
  /* Para dividir a pagina em duas colunas */
   .column {
    float: left;
    width:49%;
    justify-content: center;
    align-items: center;
  }
  
  /* Clear floats after the columns */
  .row:after {
    content: "";
    display: table;
    clear: both;
  }
  
  /* Inicio do menu tipo acordeon */
  .accordion{
    background-color: #eee;
    color: #444;
    cursor: pointer;
    padding: 18px;
    width: 100%;
    border: none;
    text-align: left;
    outline: none;
    font-size: 15px;
    transition: 0.4s;
    font-weight: bold;
  }
  .active, .accordion:hover {
    background-color: #a4b8b6;
  }
  .panel {
    /*Versao anterior do accordion usa  max-height: 0 para fazer a transition e nao aceita aninhamento de acordeon*/
    padding: 0 10px;
    background-color: #f9f9f9;
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.2s ease-out;
    margin-left: 0%;
  }
  .panel p {
    margin-left: 1%;
  }
  /*Inicio do Acordeon Aninhado*/
  button.accordionNested{
    background-color: #eee;
    color: #444;
    cursor: pointer;
    padding: 18px;
    width: 100%;
    border: none;
    text-align: left;
    outline: none;
    font-size: 15px;
    font-weight: bold;
  }
  .activeNested, .accordionNested:hover {
    background-color: #a4b8b6;
  }
  .panelNested {
    /*Aceita aninhamento mas nao faz transition*/
    padding: 0 10px;
    background-color: #f9f9f9;
    display: none;
    overflow: hidden;
    margin-left: 0%;
  }
  .panelNested p {
    margin-left: 1%;
  }
  /*Inicio do Segundo Acordeon Aninhado*/
  button.accordionNestedTwo{
    background-color: #eee;
    color: #444;
    cursor: pointer;
    padding: 18px;
    width: 100%;
    border: none;
    text-align: left;
    outline: none;
    font-size: 15px;
    font-weight: bold;
  }
  .activeNestedTwo, .accordionNestedTwo:hover {
    background-color: #a4b8b6;
  }
  .panelNestedTwo {
    /*Aceita aninhamento mas nao faz transition*/
    padding: 0 10px;
    background-color: #f9f9f9;
    display: none;
    overflow: hidden;
    margin-left: 0%;
  }
  .panelNestedTwo p {
    margin-left: 1%;
  }
  /* Fim do menu tipo acordeon */
  
  .bloco .title {
      display: block;
  }
  
  /*Bloco de solucao de exercicio*/
  .bloco .label,
  .bloco .separator {
      font-weight: bold;
  }
  
  .bloco .separator {
      margin-right: .6em;
  /*    margin-left: .6em;  */
  }
  
  /* Quiz Participacao */
  div.quiz {
    padding: 1rem;
    width: 600px;
    box-shadow: 0 15px 30px 0 rgba(0,0,0,0.11),
      0 5px 15px 0 rgba(0,0,0,0.08);
    background-color: #ffffff;
    border-radius: 0.5rem;
    border-left: 0 solid #00ff99;
    font-weight:bold;
    color:#bf360c;
  }
  
  /* Solução */
  div.solucao {
    border-left: .3em solid #dd4444;   /*#dc3c01; */
    margin-left: -.8em;
    padding-left: .4em;
    position: relative;
    font-size: 90%;
  }
  
  div.solucao .conteudo {
    display: none;
    padding-top: 1px;
  }
  
  div.solucao button {
    color: #0000AF;
    background-color: white;
    border-radius: 5px;
  }
  
  div.solucao button.viewed {
    color: #FF2020;
    background-color: white;
    border-radius: 5px;
  }
  
  div.exemplo {
    /*background-color: lightgray;*/
    margin-left: 5%;
    margin-right: 5%;
  }
  
  div.exemplo .sourceCode  {
    /*background-color: lightgray;*/
    margin-left: 2%;
    margin-right: 2%;
  }
  
  div.adicional {
    margin-left: 1%;
  }
  /* Alinhamento dos títulos e parágrafos */
  
  body{margin-left: 5%; margin-right: 5%;
           color: black; background-color: #f9f9f9;}
  
  hr{
      margin-left: -4%;
      background-color: rgb(0,150,150);  /*anterior:    240,240,240 */
  }
  h1{
      margin-left: -4%;
      /*background-color: rgb(210,210,220);*/
  }
  
  h2{
      margin-left: -4%;
      /*background-color: rgb(220,220,230);*/
  }
  
  h3{
      margin-left: 0%;  /*-4%;*/
      /*background-color: rgb(230,230,240);*/
  }
  
  h4{
      margin-left: 0%;  /*-4%;*/
      /*background-color: rgb(240,240,250);*/
  }
  h5{
      margin-left: 0%;  /*-4%;*/
      /*background-color: rgb(245,245,250);*/
  }
  
  /* Cores */
  i{color: red}
  em{color: green}
  cite{color: brown}
  /* blockquote > p { */
  blockquote{color: red}
  blockquote p {
    margin-bottom: 0;
    font-size: 14px;
    font-weight: 300;
    line-height: 2em;
  }
  
  /* ---- Front Matter ----
  Pandoc header DIV. Contains .title, .author and .date. Comes before div#TOC.
  Only appears if one of those three are in the document.   */
  
  div#header, header
      {
      /* Put border on bottom. Separates it from TOC or body that comes after it. */
      border-bottom: 1px solid #aaa;
      margin-bottom: 0.5em;
      }
  
  .title /* Pandoc title header (h1.title) */
      {
      text-align: center;
      }
  
  .author, .date /* Pandoc author(s) and date headers (h2.author and h3.date) */
      {
      text-align: center;
      }
  
  /* Pandoc table of contents DIV when using the --toc option.
     NOTE: this doesn't support Pandoc's --id-prefix option for #TOC and #header.
     Probably would need to use div[id$='TOC'] and div[id$='header'] as selectors.
  */
  
  div#TOC, nav#TOC
      {
      /* Put border on bottom to separate it from body. */
  /*    border-bottom: 1px solid #aaa;   */
      margin-bottom: 0.5em;
      }
  
  @media print
      {
      div#TOC, nav#TOC
          {
          /* Don't display TOC in print */
          display: none;
          }
      }
  /* ---- Images ---- */
  img {
      /* Let it be inline left/right where it wants to be, but verticality make
         it in the middle to look nicer, but opinions differ, and if in a multi-line
         paragraph, it might not be so great.
         vertical-align: middle;
      */
      vertical-align: middle;
      max-width: 600px;
      height:auto;
      }
  div.figure /* Pandoc figure-style image */
      {
      /* Center the image and caption */
      margin-left: auto;
      margin-right: auto;
      text-align: center;
      font-style: italic;
      max-width: 600px;
      height:auto;
      }
  p.caption /* Pandoc figure-style caption within div.figure */
      {
      /* Inherits div.figure props by default */
      }
  /* ---- Tables ---- */
  table {
      margin-left: auto;
      margin-right: auto;
      margin-bottom: 24px;
      border-spacing: 0;
      border-bottom: 2px solid black;
      border-top: 2px solid black;
  }
  table th {
      padding: 3px 10px;
      background-color: white;
      border-top: 1px;
      border-left: 1px;
      border-right: 1px;
      border-bottom: 1px solid black;
  }
  table td {
      padding: 3px 10px;
      border-top: 1px;
      border-left: 1px;
      border-bottom: 1px;
      border-right: 1px;
  }
  /* fundo para as linhas das tabelas */
  tr.even{
    background-color: rgb(230,230,240);
  }
  tr.odd{
    background-color: rgb(250,250,250);
  }
  </style>
  
  
  <script type="text/javascript">
      function exibe(e)
      {
          var div = e.parentNode.firstElementChild;
          var nome = e.parentNode.id;
          var tipo=nome.substring(0, 3).toUpperCase()
          switch (tipo) {
            case "SOL":
                nome = "Solução";
                break;
            case "COD":
                nome = "Código";
                break;
            case "DIC":
                nome = "Dica";
                break;
            case "DIA":
                nome = "Diagrama";
                break;
            case "RES":
                nome = "Resumo";
                break;
            case "CON":
                nome = "Conteúdo";
                break;
            default:
                nome = "";
            }
  
          if (div.style.display == "" || div.style.display == "none") {
              div.style.display = "block";
              e.setAttribute("class", "viewed");
              e.innerHTML = "Esconder ";
          } else {
              div.style.display = "none";
              e.innerHTML = "Exibir "+nome;
          }
      }
      function validaBinario(nome) {
          var valor, tamanho, i;
          document.getElementById(nome).style.color = "black";
          valor = document.getElementById(nome).value;
          tamanho=valor.length;
          for (i=0;i<tamanho; i=i+1){
              if ( valor[i] != 1 && valor[i] != 0 ){
                  document.getElementById(nome).style.color = "red";
              }
          }
      }
  </script>
</head>
<body>
<h1 id="aula-2-fluxo-de-dados-fd">Aula 2: Fluxo de Dados (FD)</h1>
<p><strong>Questão:</strong> Como automatizar o funcionamento do fluxo de dados?</p>
<h2 id="objetivos">Objetivos</h2>
<ol type="1">
<li>Utilizar memória em VHDL.</li>
</ol>
<hr />
<h2 id="contextualização">Contextualização</h2>
<p>No início da aula passada, vimos um fluxo de dados que não reutiliza nenhuma unidade funcional e soluciona a equação através do encadeamento adequado das unidades funcionais disponíveis (baseada no projeto do ENIAC).</p>
<p>A primeira melhoria implementada, foi refazer o projeto para que pudessemos reutilizar as unidades funcionais durante o cálculo. Isso foi possível através de elementos que armazenam os resultados intermediários, os registradores, e da utilização de um fluxo de dados que fosse reconfigurável dinamicamente, utilizando MUXes e uma ULA.</p>
<figure>
<img src="imagensCircuitos/fluxoDadosEquacaoGrau+Chaves_2-2021s2.svg" alt="Diagrama do Circuito Anterior" style="width:600px;" /><figcaption><strong>Diagrama do Circuito Anterior</strong></figcaption>
</figure>
<p>Até agora, para reconfigurar o FD, utilizamos algumas chaves seletoras - uma unidade de controle operada manualmente. Durante a execução da solução de uma equação, a configuração dessas chaves deve ser alterada de acordo com essa equação dada. Isso tornou o circuito muito mais simples. Porém, ainda temos que “pilotar” o processamento da solução.</p>
<p>A nossa próxima alteração no projeto tem como objetivo automatizar essa reconfiguração dinâmica das chaves. Para resolver esse problema, utilizaremos uma memória para armazenar a sequência de ativação dos pontos de controle. O conteúdo de cada posição dessa memória, que é a combinação de controle para uma determinada operação, é chamado de <em>palavra de controle</em>.</p>
<p>O primeiro passo é entender como funciona uma memória e como implementá-la em VHDL.</p>
<button class="accordion">
Memórias (7 minutos)
</button>
<div class="panel">
<p>A abstração para o componente memória é um vetor de dados com <em>n</em> posições e cada posição com <em>m</em> bits. Ou seja, temos <em>n</em> registradores e cada registrador possui <em>m</em> bits. No exemplo abaixo, temos <em>n = 64</em> posições e <em>m = 8</em> bits. Essa forma de representação da memória é mais coerente com a visão do programador de computadores.</p>
<figure>
<img src="imagensCircuitos/memoriaVetor-1.svg" alt="Representação da Memória como um Vetor" style="width:200px;max-width:100%;" /><figcaption><strong>Representação da Memória como um Vetor</strong></figcaption>
</figure>
<p><br></p>
<p>Outra forma de representar a memória é considerá-la como uma matriz bidimensional. Essa forma está mais próxima do projeto da memória, como pode ser visto no esquema de uma memória RAM de 4 bits e 4 posições mostrado abaixo.</p>
<figure>
<img src="imagensCircuitos/memoriaRAM.svg" alt="Representação da Memória como uma Matriz" style="max-width:100%;" /><figcaption><strong>Representação da Memória como uma Matriz</strong></figcaption>
</figure>
<p><br></p>
<p>De uma forma simplificada, a memória é composta de dois blocos funcionais:</p>
<ul>
<li><p>O decodificador de endereços;</p></li>
<li><p>A célula de armazenamento individual, de 1 bit.</p></li>
</ul>
<p><br></p>
<p><strong>Decodificador de Endereços</strong></p>
<p>Para um decodificador com <em>n</em> bits de entrada, ele converte essa entrada, da representação binária, para a representação 1 de <em>2^n</em>. Ou seja, de acordo com o valor binário de entrada, somente uma linha de saída será ativada - a correspondente à conversão desse valor para decimal.</p>
<p>Para o exemplo da memória com 4 posições e 4 bits por posição, o decodificador utilizado seria o mostrado abaixo.</p>
<figure>
<img src="imagensCircuitos/decodificador_2_para_4-Circuito-A.svg" alt="Decodificador" style="width:400px;max-width:100%;" /><figcaption><strong>Decodificador</strong></figcaption>
</figure>
<p>Dessa forma, temos somente uma linha ativada a cada momento. A linha que estiver ativa, ativará os transistores de conexão da célula com a saída de dados, permitindo que haja a leitura de todos os bits de somente uma posição da memória por vez.</p>
<p><br></p>
<p><strong>Célula de Armazenamento</strong></p>
<p>No caso da memória estática, para cada célula (bit), temos um circuito similar ao abaixo.</p>
<figure>
<img src="imagensCircuitos/Celula_1_Bit.svg" alt="Circuito de uma Célula de Armazenamento" style="width:300px;max-width:100%;" /><figcaption><strong>Circuito de uma Célula de Armazenamento</strong></figcaption>
</figure>
<p>A realimentação entre os inversores força o circuito a uma saída estável, enquanto os transistores são utilizados como chave de conexão entre o estado armazenado e as linhas de saída. O circuito de escrita na célula não está nesse diagrama.</p>
<p>De uma forma muito geral, podemos dividir as memórias em dois grupos:</p>
<ul>
<li><p>As que podem ser lidas e escritas dinamicamente:</p>
<ul>
<li>RAM (<em>Random Access Memory</em>);</li>
</ul></li>
<li><p>As que podem ser escritas somente durante a sua fabricação/implementação no produto e lidas dinamicamente:</p>
<ul>
<li>ROM (<em>Read Only Memory</em>).</li>
</ul></li>
</ul>
<br>
<div class="quiz" style="width:600px;">
<div class="row">
<div class="column" style="width:60px;">
<p><img src="imagensComponentes/Pare.svg" style="width:30px;" /></p>
</div>
<div class="column" style="width:500px;">
<p>
Responder o quiz de participação, no blackboard, em:
</p>
<p>
Conteúdos &gt; Participação &gt; Aula_2_Quiz-P1
</p>
</div>
</div>
</div>
<p><br></p>
</div>
<!--- class_panel --->
<button class="accordion">
Memória em VHDL (7 minutos)
</button>
<div class="panel">
<p>Como visto acima, a abstração de uma memória, mais próxima ao seu projeto, é a matriz. Portanto, faz todo sentido utilizar um <em>array em VHDL</em> para descrever uma memória.</p>
<p>Em VHDL, o <em>array</em> é um tipo de dados composto que armazena uma coleção de dados de um mesmo tipo. A localização desses dados é indexada através de um valor do <strong>tipo escalar</strong> (geralmente um <em>natural</em>).</p>
<p>Um exemplo de <em>array</em> é o <em>std_logic_vector</em>. Ele é um conjunto de dados do tipo <em>std_logic</em>, que está definido dentro do pacote <em>std_logic_1164</em> da biblioteca <em>ieee</em>.</p>
<p>No caso das memórias precisamos de um <em>array</em> bidimensional. Ele pode ser descrito utilizando um tipo que é um <em>array</em> de um subtipo. Como o endereçamento memória é binário, a capacidade da memória (quantidade de posições) deve ser do tipo <em>2^n</em>, onde <em>n</em> é o número de linhas (bits) de endereçamento.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode vhd"><code class="sourceCode vhdl"><a class="sourceLine" id="cb1-1" title="1">    subtype word_t is std_logic_vector((DATA_WIDTH<span class="ot">-</span>1) downto 0);   <span class="co">-- A definição do conteúdo de cada posição (a palavra de dados).</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3">    type memory_t is array(2<span class="ot">**</span>ADDR_WIDTH<span class="ot">-</span>1 downto 0) of word_t;  <span class="co">-- A definição da quantidade de endereços (posições) da memória (2^n).</span></a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5">    signal ram <span class="ot">:</span> memory_t;</a></code></pre></div>
<p>Para ter uma maior riqueza de informações durante a simulação, é boa prática utilizar os sinais, que interligam os componentes em VHDL, do tipo <em>std_logic</em> - que possui 9 estados e não somente o estado lógico um e o estado lógico zero.</p>
<p>Porém, o índice do <em>array</em> tem de ser do tipo escalar e portanto, é necessário fazer a conversão de tipos entre o endereço da memória (prensente na definição da entidade e preferencialmente um <em>std_logic</em>) e o endereço utilizado para acessar o <em>array</em> (escalar).</p>
<p>Para os projetos que serão executados, o ideal é utilizar uma memória com a escrita sincronizada pelo <em>clock</em> e com a leitura assíncrona.</p>
<p>Abaixo, temos o modelo VHDL para uma memória ROM com a inicialização dos seus valores embutida no código (função <em>initMemory</em>).</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><a class="sourceLine" id="cb2-1" title="1"></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="kw">library</span> IEEE;</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">use</span> IEEE<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="kw">use</span> ieee<span class="ot">.</span>numeric_std<span class="ot">.</span>all;</a>
<a class="sourceLine" id="cb2-5" title="5"></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="kw">entity</span> <span class="kw">memoria</span> <span class="kw">is</span></a>
<a class="sourceLine" id="cb2-7" title="7">   <span class="kw">generic</span> (</a>
<a class="sourceLine" id="cb2-8" title="8">          dataWidth<span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb2-9" title="9">          addrWidth<span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb2-10" title="10">    );</a>
<a class="sourceLine" id="cb2-11" title="11">   <span class="kw">port</span> (</a>
<a class="sourceLine" id="cb2-12" title="12">          <span class="co">-- O fato da interface ser do tipo std_logic auxilía na simulação.</span></a>
<a class="sourceLine" id="cb2-13" title="13">          Endereco <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span> (addrWidth<span class="ot">-</span><span class="dv">1</span> <span class="ot">DOWNTO</span> <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb2-14" title="14">          Dado <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span> (dataWidth<span class="ot">-</span><span class="dv">1</span> <span class="ot">DOWNTO</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb2-15" title="15">    );</a>
<a class="sourceLine" id="cb2-16" title="16"><span class="kw">end entity;</span></a>
<a class="sourceLine" id="cb2-17" title="17"></a>
<a class="sourceLine" id="cb2-18" title="18"><span class="kw">architecture</span> <span class="kw">assincrona</span> <span class="kw">of</span> <span class="kw">memoria</span> <span class="kw">is</span></a>
<a class="sourceLine" id="cb2-19" title="19"></a>
<a class="sourceLine" id="cb2-20" title="20">  <span class="ot">type</span> blocoMemoria <span class="kw">is</span> <span class="kw">array</span>(<span class="dv">0</span> <span class="ot">TO</span> <span class="dv">2</span><span class="ot">**</span>addrWidth <span class="ot">-</span> <span class="dv">1</span>) <span class="kw">of</span> <span class="dt">std_logic_vector</span>(dataWidth<span class="ot">-</span><span class="dv">1</span> <span class="ot">DOWNTO</span> <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb2-21" title="21"></a>
<a class="sourceLine" id="cb2-22" title="22">  <span class="kw">function</span> initMemory</a>
<a class="sourceLine" id="cb2-23" title="23">        <span class="co">-- Inicializa todas as posições da memória com zero:</span></a>
<a class="sourceLine" id="cb2-24" title="24">        <span class="kw">return</span> blocoMemoria <span class="kw">is</span> <span class="ot">variable</span> tmp <span class="ot">:</span> blocoMemoria <span class="ot">:=</span> (<span class="ot">others</span> <span class="ot">=&gt;</span> (<span class="ot">others</span> <span class="ot">=&gt;</span> <span class="bn">&#39;0&#39;</span>));</a>
<a class="sourceLine" id="cb2-25" title="25">  <span class="kw">begin</span></a>
<a class="sourceLine" id="cb2-26" title="26">        <span class="co">-- Inicializa os endereços desejados. Os demais endereços conterão o valor zero:</span></a>
<a class="sourceLine" id="cb2-27" title="27">        tmp(<span class="dv">0</span>) <span class="ot">:=</span> x<span class="st">&quot;AA&quot;</span>;</a>
<a class="sourceLine" id="cb2-28" title="28">        tmp(<span class="dv">1</span>) <span class="ot">:=</span> x<span class="st">&quot;42&quot;</span>;</a>
<a class="sourceLine" id="cb2-29" title="29">        tmp(<span class="dv">2</span>) <span class="ot">:=</span> x<span class="st">&quot;43&quot;</span>;</a>
<a class="sourceLine" id="cb2-30" title="30">        tmp(<span class="dv">3</span>) <span class="ot">:=</span> x<span class="st">&quot;44&quot;</span>;</a>
<a class="sourceLine" id="cb2-31" title="31">        tmp(<span class="dv">4</span>) <span class="ot">:=</span> x<span class="st">&quot;45&quot;</span>;</a>
<a class="sourceLine" id="cb2-32" title="32">        tmp(<span class="dv">5</span>) <span class="ot">:=</span> x<span class="st">&quot;46&quot;</span>;</a>
<a class="sourceLine" id="cb2-33" title="33">        tmp(<span class="dv">6</span>) <span class="ot">:=</span> x<span class="st">&quot;47&quot;</span>;</a>
<a class="sourceLine" id="cb2-34" title="34">        tmp(<span class="dv">7</span>) <span class="ot">:=</span> x<span class="st">&quot;55&quot;</span>;</a>
<a class="sourceLine" id="cb2-35" title="35">        <span class="kw">return</span> tmp;</a>
<a class="sourceLine" id="cb2-36" title="36">    <span class="kw">end </span>initMemory;</a>
<a class="sourceLine" id="cb2-37" title="37"></a>
<a class="sourceLine" id="cb2-38" title="38">    <span class="ot">signal</span> memROM <span class="ot">:</span> blocoMemoria <span class="ot">:=</span> initMemory;</a>
<a class="sourceLine" id="cb2-39" title="39"></a>
<a class="sourceLine" id="cb2-40" title="40"><span class="kw">begin</span></a>
<a class="sourceLine" id="cb2-41" title="41">    <span class="co">-- A conversão de tipos para obter o índice do vetor que será acessado:</span></a>
<a class="sourceLine" id="cb2-42" title="42">    Dado <span class="ot">&lt;=</span> memROM (to_integer(<span class="dt">unsigned</span>(Endereco)));</a>
<a class="sourceLine" id="cb2-43" title="43"><span class="kw">end architecture;</span></a></code></pre></div>
<h4 id="memória-e-fpga">Memória e FPGA</h4>
<p>A FPGA possui, além dos blocos lógicos, os blocos de DSP e os blocos dedicados de memória. Para pequenas quantidades de memória, pode-se implementar utilizando os registradores dos blocos lógicos. Porém, para tamanhos maiores de memória, pode-se economizar os blocos lógicos usando os blocos de memória.</p>
<p>Para fazer com que a ferramenta de síntese mapeie o código VHDL para os blocos de memória, são necessários alguns cuidados:</p>
<ul>
<li><p>Usar memória com escrita síncrona;</p></li>
<li><p>Evitar uso de <em>reset</em> no código da memória;</p></li>
<li><p>Verificar se a leitura durante a escrita, se existir, é coerente com o modelo da FPGA;</p></li>
<li><p>Entre outros.</p></li>
</ul>
<p>A Intel (Altera) indica, no manual de boas práticas de codificação, que sejam utilizados os modelos por ela fornecidos. Veja os modelos disponíveis nos <em>templates</em> do Quartus, que também foram usados na Aba <em>Modelos VHDL</em>.</p>
<br>
<div class="quiz" style="width:600px;">
<div class="row">
<div class="column" style="width:60px;">
<p><img src="imagensComponentes/Pare.svg" style="width:30px;" /></p>
</div>
<div class="column" style="width:500px;">
<p>
Responder o quiz de participação, no blackboard, em:
</p>
<p>
Conteúdos &gt; Participação &gt; Aula_2_Quiz-P2
</p>
</div>
</div>
</div>
<p><br></p>
</div>
<!--- class_panel --->
<hr />
<h2 id="atividade-1-implementação-e-simulação-de-memória-em-vhdl">Atividade 1: Implementação e Simulação de Memória em VHDL</h2>
<button class="accordion">
Procedimento
</button>
<div class="panel">
<p>Implemente e simule uma memória ROM com as seguintes características:</p>
<ul>
<li><p>1024 posições e 8 bits por posição;</p></li>
<li><p>Contendo o seu nome escrito em ASCII.</p></li>
</ul>
<p>Para simular, crie um vetor de contagem que irá “alimentar” o endereçamento da memória.</p>
<blockquote>
<p><strong>Durante a simulação, utilize a exibição em ASCII para os dados de saída da memória.</strong></p>
</blockquote>
<!--
Duas dicas:

-   A entrada de dados, deve ser feita através das chaves;

-   Para gravar o projeto na FPGA, o _clock_ deve continuar a ser gerado pelo conjunto botão e discriminador de borda;

    -   Para simular, é mais fácil remover o discriminador de borda (veja o "if generate" no código do _top_level_).
-->
</div>
<!--- class_panel --->
<hr />
<h2 id="projeto-do-circuito">Projeto do Circuito</h2>
<button class="accordion">
Etapa 1: Adicionando a Memória de Controle ao Computador para Cálculo de Equações do Primeiro Grau
</button>
<div class="panel">
<p>Para automatizar o nosso computador, vamos iniciar com a memória de armazenamento das palavras de controle.</p>
<p>Essa memória deve possuir uma quantidade de posições suficiente para armazenar todos os passos vistos na aula anterior. Cada posição deve poder armazenar a mesma quantidade de bits da palavra de controle, neste caso, 4 bits.</p>
<p>Assim, quando for feito o acesso em sequência, de todos endereços da memória, deverá aparecer, na saída de dados, a sequência de palavras de controle necessárias para executar o processamento da equação <em>3x - 4</em> (a mesma da aula passada).</p>
<p><img src="imagensCircuitos/fluxoDadosEquacaoGrau+Memoria-DE0-CV-2022s1-A.svg" style="width:800px;" /></p>
</div>
<!--- class_panel --->
<button class="accordion">
Etapa 2: Fazendo o Sequenciamento das Operações
</button>
<div class="panel">
<p>O módulo que determina o endereço da próxima palavra de controle é um somador, que incrementa o endereço atual para obter o próximo endereço (ou próximo PC).</p>
<p>Vamos intergrar esse módulo ao nosso computador e executar o programa para resolver a equação: <em>S = 3x - 4</em>.</p>
<p><img src="imagensCircuitos/fluxoDadosEquacaoGrau+Memoria-DE0-CV-2022s1-B.svg" style="width:800px;" /></p>
<br>
<div class="quiz" style="width:600px;">
<div class="row">
<div class="column" style="width:60px;">
<p><img src="imagensComponentes/Pare.svg" style="width:30px;" /></p>
</div>
<div class="column" style="width:500px;">
<p>
Responder o quiz de participação, no blackboard, em:
</p>
<p>
Conteúdos &gt; Participação &gt; Aula_2_Quiz-P3
</p>
</div>
</div>
</div>
<p><br></p>
</div>
<!--- class_panel --->
<hr />
<h2 id="atividade-2-implementação-em-vhdl-do-computador">Atividade 2: Implementação em VHDL do Computador</h2>
<button class="accordion">
Procedimento
</button>
<div class="panel">
<p>Podemos reutilizar os módulos do projeto passado, atualizando somente o <em>top level</em> e adicionando a <em>ROM</em>.</p>
<p>Ambos arquivos estão mostrados abaixo.</p>
<p>É necessário acertar o conteúdo da ROM de acordo com a tabela de palavras de controle, mostrada abaixo.</p>
<!-- Com a utilização da ROM não é mais necessário utilizar a porta inversora no sinal de _Reset_, já que podemos inverter o sinal gravado na ROM. -->
<table>
<caption><strong>Sequência das Palavras de Controle da Aula 1</strong></caption>
<colgroup>
<col style="width: 9%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Sequência</th>
<th style="text-align: center;">Entrada De Dados: X</th>
<th style="text-align: center;">Valor de Sel MUX</th>
<th style="text-align: center;">Habilita A</th>
<th style="text-align: center;">Reset A</th>
<th style="text-align: center;">Operação</th>
<th style="text-align: center;">Clock</th>
<th style="text-align: left;">Comentário</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">N.I.</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">↑</td>
<td style="text-align: left;">Zera o Registrador do Acumulador</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">↑</td>
<td style="text-align: left;">Soma “X” com zero e armazena no Acumulador</td>
</tr>
<tr class="odd">
<td style="text-align: center;">2</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">↑</td>
<td style="text-align: left;">Soma “X” com “X” e armazena no Acumulador</td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">↑</td>
<td style="text-align: left;">Soma “X” com “2X” e armazena no Acumulador</td>
</tr>
<tr class="odd">
<td style="text-align: center;">4</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">↑</td>
<td style="text-align: left;">Subtrai “4” de “3X” e armazena no Acumulador</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>O Reg A também é chamado de Acumulador.</strong></p>
</blockquote>
<p>Os arquivos estão listados abaixo. A ROM deverá ter o seu conteúdo ajustado conforme a tabela acima. Para esta equação, como temos somente 5 passos, podemos utilizar uma ROM com 8 posições.</p>
<p>Note que o circuito com o somador, chamado de <em>somaConstante</em>, está nos <strong>Modelos VHDL</strong>.</p>
<h3 id="top-level">Top Level</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">library</span> ieee;</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">use</span> ieee<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;</a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="kw">entity</span> <span class="kw">Aula2</span> <span class="kw">is</span></a>
<a class="sourceLine" id="cb3-5" title="5">  <span class="co">-- Total de bits das entradas e saidas</span></a>
<a class="sourceLine" id="cb3-6" title="6">  <span class="kw">generic</span> ( larguraDados <span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">4</span>;</a>
<a class="sourceLine" id="cb3-7" title="7">        larguraEnderecos <span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">3</span>;</a>
<a class="sourceLine" id="cb3-8" title="8">        simulacao <span class="ot">:</span> <span class="dt">boolean</span> <span class="ot">:=</span> TRUE <span class="co">-- para gravar na placa, altere de TRUE para FALSE</span></a>
<a class="sourceLine" id="cb3-9" title="9">  );</a>
<a class="sourceLine" id="cb3-10" title="10">  <span class="kw">port</span>   (</a>
<a class="sourceLine" id="cb3-11" title="11">    CLOCK_<span class="dv">50</span> <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span>;</a>
<a class="sourceLine" id="cb3-12" title="12">    KEY<span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span>(<span class="dv">3</span> <span class="ot">downto</span> <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb3-13" title="13">    SW<span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span>(<span class="dv">9</span> <span class="ot">downto</span> <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb3-14" title="14">   PC_OUT<span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span>(larguraEnderecos<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb3-15" title="15">    LEDR  <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span>(<span class="dv">9</span> <span class="ot">downto</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb3-16" title="16">  );</a>
<a class="sourceLine" id="cb3-17" title="17"><span class="kw">end entity;</span></a>
<a class="sourceLine" id="cb3-18" title="18"></a>
<a class="sourceLine" id="cb3-19" title="19"></a>
<a class="sourceLine" id="cb3-20" title="20"><span class="kw">architecture</span> <span class="kw">arquitetura</span> <span class="kw">of</span> <span class="kw">Aula2</span> <span class="kw">is</span></a>
<a class="sourceLine" id="cb3-21" title="21"></a>
<a class="sourceLine" id="cb3-22" title="22">  <span class="ot">signal</span> chavesX_ULA_B <span class="ot">:</span> <span class="dt">std_logic_vector</span> (larguraDados<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb3-23" title="23">  <span class="ot">signal</span> chavesY_MUX_A <span class="ot">:</span> <span class="dt">std_logic_vector</span> (larguraDados<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb3-24" title="24">  <span class="ot">signal</span> MUX_REG1 <span class="ot">:</span> <span class="dt">std_logic_vector</span> (larguraDados<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb3-25" title="25">  <span class="ot">signal</span> REG1_ULA_A <span class="ot">:</span> <span class="dt">std_logic_vector</span> (larguraDados<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb3-26" title="26">  <span class="ot">signal</span> Saida_ULA <span class="ot">:</span> <span class="dt">std_logic_vector</span> (larguraDados<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb3-27" title="27">  <span class="ot">signal</span> Sinais_Controle <span class="ot">:</span> <span class="dt">std_logic_vector</span> (<span class="dv">3</span> <span class="ot">downto</span> <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb3-28" title="28">  <span class="ot">signal</span> Endereco <span class="ot">:</span> <span class="dt">std_logic_vector</span> (<span class="dv">2</span> <span class="ot">downto</span> <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb3-29" title="29">  <span class="ot">signal</span> proxPC <span class="ot">:</span> <span class="dt">std_logic_vector</span> (<span class="dv">2</span> <span class="ot">downto</span> <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb3-30" title="30">  <span class="ot">signal</span> Chave_Operacao_ULA <span class="ot">:</span> <span class="dt">std_logic</span>;</a>
<a class="sourceLine" id="cb3-31" title="31">  <span class="ot">signal</span> CLK <span class="ot">:</span> <span class="dt">std_logic</span>;</a>
<a class="sourceLine" id="cb3-32" title="32">  <span class="ot">signal</span> SelMUX <span class="ot">:</span> <span class="dt">std_logic</span>;</a>
<a class="sourceLine" id="cb3-33" title="33">  <span class="ot">signal</span> Habilita_A <span class="ot">:</span> <span class="dt">std_logic</span>;</a>
<a class="sourceLine" id="cb3-34" title="34">  <span class="ot">signal</span> Reset_A <span class="ot">:</span> <span class="dt">std_logic</span>;</a>
<a class="sourceLine" id="cb3-35" title="35">  <span class="ot">signal</span> Operacao_ULA <span class="ot">:</span> <span class="dt">std_logic</span>;</a>
<a class="sourceLine" id="cb3-36" title="36"></a>
<a class="sourceLine" id="cb3-37" title="37"><span class="kw">begin</span></a>
<a class="sourceLine" id="cb3-38" title="38"></a>
<a class="sourceLine" id="cb3-39" title="39"><span class="co">-- Instanciando os componentes:</span></a>
<a class="sourceLine" id="cb3-40" title="40"></a>
<a class="sourceLine" id="cb3-41" title="41"><span class="co">-- Para simular, fica mais simples tirar o edgeDetector</span></a>
<a class="sourceLine" id="cb3-42" title="42"><span class="kw">gravar</span><span class="ot">:</span>  <span class="kw">if</span> simulacao <span class="kw">generate</span></a>
<a class="sourceLine" id="cb3-43" title="43">CLK <span class="ot">&lt;=</span> KEY(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb3-44" title="44">else <span class="kw">generate</span></a>
<a class="sourceLine" id="cb3-45" title="45"><span class="kw">detectorSub0</span><span class="ot">:</span> <span class="er">work</span><span class="ot">.</span><span class="er">edgeDetector(bordaSubida)</span></a>
<a class="sourceLine" id="cb3-46" title="46">        <span class="kw">port map (</span>clk <span class="ot">=&gt;</span> CLOCK_<span class="dv">50</span><span class="ot">,</span> entrada <span class="ot">=&gt;</span> (<span class="kw">not</span> KEY(<span class="dv">0</span>))<span class="ot">,</span> saida <span class="ot">=&gt;</span> CLK);</a>
<a class="sourceLine" id="cb3-47" title="47"><span class="kw">end generate</span>;</a>
<a class="sourceLine" id="cb3-48" title="48"></a>
<a class="sourceLine" id="cb3-49" title="49"><span class="co">-- O port map completo do MUX.</span></a>
<a class="sourceLine" id="cb3-50" title="50"><span class="kw">MUX1</span> <span class="ot">:</span>  <span class="er">entity</span> <span class="er">work</span><span class="ot">.</span><span class="er">muxGenerico2x1</span>  <span class="kw">generic map (</span>larguraDados <span class="ot">=&gt;</span> larguraDados)</a>
<a class="sourceLine" id="cb3-51" title="51">        <span class="kw">port map(</span> entradaA_MUX <span class="ot">=&gt;</span> chavesY_MUX_A<span class="ot">,</span></a>
<a class="sourceLine" id="cb3-52" title="52">                 entradaB_MUX <span class="ot">=&gt;</span>  Saida_ULA<span class="ot">,</span></a>
<a class="sourceLine" id="cb3-53" title="53">                 seletor_MUX <span class="ot">=&gt;</span> SelMUX<span class="ot">,</span></a>
<a class="sourceLine" id="cb3-54" title="54">                 saida_MUX <span class="ot">=&gt;</span> MUX_REG1);</a>
<a class="sourceLine" id="cb3-55" title="55"></a>
<a class="sourceLine" id="cb3-56" title="56"><span class="co">-- O port map completo do Acumulador.</span></a>
<a class="sourceLine" id="cb3-57" title="57"><span class="kw">REGA</span> <span class="ot">:</span> <span class="er">entity</span> <span class="er">work</span><span class="ot">.</span><span class="er">registradorGenerico</span>   <span class="kw">generic map (</span>larguraDados <span class="ot">=&gt;</span> larguraDados)</a>
<a class="sourceLine" id="cb3-58" title="58">          <span class="kw">port map (</span>DIN <span class="ot">=&gt;</span> MUX_REG1<span class="ot">,</span> DOUT <span class="ot">=&gt;</span> REG1_ULA_A<span class="ot">,</span> ENABLE <span class="ot">=&gt;</span> Habilita_A<span class="ot">,</span> CLK <span class="ot">=&gt;</span> CLK<span class="ot">,</span> RST <span class="ot">=&gt;</span> Reset_A);</a>
<a class="sourceLine" id="cb3-59" title="59"></a>
<a class="sourceLine" id="cb3-60" title="60"><span class="co">-- O port map completo do Program Counter.</span></a>
<a class="sourceLine" id="cb3-61" title="61"><span class="kw">PC</span> <span class="ot">:</span> <span class="er">entity</span> <span class="er">work</span><span class="ot">.</span><span class="er">registradorGenerico</span>   <span class="kw">generic map (</span>larguraDados <span class="ot">=&gt;</span> larguraEnderecos)</a>
<a class="sourceLine" id="cb3-62" title="62">          <span class="kw">port map (</span>DIN <span class="ot">=&gt;</span> proxPC<span class="ot">,</span> DOUT <span class="ot">=&gt;</span> Endereco<span class="ot">,</span> ENABLE <span class="ot">=&gt;</span> <span class="bn">&#39;1&#39;</span><span class="ot">,</span> CLK <span class="ot">=&gt;</span> CLK<span class="ot">,</span> RST <span class="ot">=&gt;</span> <span class="bn">&#39;0&#39;</span>);</a>
<a class="sourceLine" id="cb3-63" title="63"></a>
<a class="sourceLine" id="cb3-64" title="64"><span class="kw">incrementaPC</span> <span class="ot">:</span>  <span class="er">entity</span> <span class="er">work</span><span class="ot">.</span><span class="er">somaConstante</span>  <span class="kw">generic map (</span>larguraDados <span class="ot">=&gt;</span> larguraEnderecos<span class="ot">,</span> constante <span class="ot">=&gt;</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb3-65" title="65">        <span class="kw">port map(</span> entrada <span class="ot">=&gt;</span> Endereco<span class="ot">,</span> saida <span class="ot">=&gt;</span> proxPC);</a>
<a class="sourceLine" id="cb3-66" title="66"></a>
<a class="sourceLine" id="cb3-67" title="67"></a>
<a class="sourceLine" id="cb3-68" title="68"><span class="co">-- O port map completo da ULA:</span></a>
<a class="sourceLine" id="cb3-69" title="69"><span class="kw">ULA1</span> <span class="ot">:</span> <span class="er">entity</span> <span class="er">work</span><span class="ot">.</span><span class="er">ULASomaSub</span>  <span class="kw">generic map(</span>larguraDados <span class="ot">=&gt;</span> larguraDados)</a>
<a class="sourceLine" id="cb3-70" title="70">          <span class="kw">port map (</span>entradaA <span class="ot">=&gt;</span> REG1_ULA_A<span class="ot">,</span> entradaB <span class="ot">=&gt;</span> chavesX_ULA_B<span class="ot">,</span> saida <span class="ot">=&gt;</span> Saida_ULA<span class="ot">,</span> seletor <span class="ot">=&gt;</span> Operacao_ULA);</a>
<a class="sourceLine" id="cb3-71" title="71"></a>
<a class="sourceLine" id="cb3-72" title="72"><span class="co">-- Falta acertar o conteudo da ROM (no arquivo memoriaROM.vhd)</span></a>
<a class="sourceLine" id="cb3-73" title="73"><span class="kw">ROM1</span> <span class="ot">:</span> <span class="er">entity</span> <span class="er">work</span><span class="ot">.</span><span class="er">memoriaROM</span>   <span class="kw">generic map (</span>dataWidth <span class="ot">=&gt;</span> larguraDados<span class="ot">,</span> addrWidth <span class="ot">=&gt;</span> larguraEnderecos)</a>
<a class="sourceLine" id="cb3-74" title="74">          <span class="kw">port map (</span>Endereco <span class="ot">=&gt;</span> Endereco<span class="ot">,</span> Dado <span class="ot">=&gt;</span> Sinais_Controle);</a>
<a class="sourceLine" id="cb3-75" title="75"></a>
<a class="sourceLine" id="cb3-76" title="76"></a>
<a class="sourceLine" id="cb3-77" title="77">selMUX <span class="ot">&lt;=</span> Sinais_Controle(<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb3-78" title="78">Habilita_A <span class="ot">&lt;=</span> Sinais_Controle(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb3-79" title="79">Reset_A <span class="ot">&lt;=</span> Sinais_Controle(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb3-80" title="80">Operacao_ULA <span class="ot">&lt;=</span> Sinais_Controle(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb3-81" title="81"></a>
<a class="sourceLine" id="cb3-82" title="82"><span class="co">-- I/O</span></a>
<a class="sourceLine" id="cb3-83" title="83">chavesY_MUX_A <span class="ot">&lt;=</span> SW(<span class="dv">3</span> <span class="ot">downto</span> <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb3-84" title="84">chavesX_ULA_B <span class="ot">&lt;=</span> SW(<span class="dv">9</span> <span class="ot">downto</span> <span class="dv">6</span>);</a>
<a class="sourceLine" id="cb3-85" title="85"></a>
<a class="sourceLine" id="cb3-86" title="86"><span class="co">-- A ligacao dos LEDs:</span></a>
<a class="sourceLine" id="cb3-87" title="87">LEDR (<span class="dv">9</span>) <span class="ot">&lt;=</span> SelMUX;</a>
<a class="sourceLine" id="cb3-88" title="88">LEDR (<span class="dv">8</span>) <span class="ot">&lt;=</span> Habilita_A;</a>
<a class="sourceLine" id="cb3-89" title="89">LEDR (<span class="dv">7</span>) <span class="ot">&lt;=</span> Reset_A;</a>
<a class="sourceLine" id="cb3-90" title="90">LEDR (<span class="dv">6</span>) <span class="ot">&lt;=</span> Operacao_ULA;</a>
<a class="sourceLine" id="cb3-91" title="91">LEDR (<span class="dv">5</span>) <span class="ot">&lt;=</span> <span class="bn">&#39;0&#39;</span>;    <span class="co">-- Apagado.</span></a>
<a class="sourceLine" id="cb3-92" title="92">LEDR (<span class="dv">4</span>) <span class="ot">&lt;=</span> <span class="bn">&#39;0&#39;</span>;    <span class="co">-- Apagado.</span></a>
<a class="sourceLine" id="cb3-93" title="93">LEDR (<span class="dv">3</span> <span class="ot">downto</span> <span class="dv">0</span>) <span class="ot">&lt;=</span> REG1_ULA_A;</a>
<a class="sourceLine" id="cb3-94" title="94"></a>
<a class="sourceLine" id="cb3-95" title="95">PC_OUT <span class="ot">&lt;=</span> Endereco;</a>
<a class="sourceLine" id="cb3-96" title="96"></a>
<a class="sourceLine" id="cb3-97" title="97"><span class="kw">end architecture;</span></a></code></pre></div>
<h3 id="rom">ROM</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">library</span> IEEE;</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">use</span> IEEE<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">use</span> ieee<span class="ot">.</span>numeric_std<span class="ot">.</span>all;</a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="kw">entity</span> <span class="kw">memoriaROM</span> <span class="kw">is</span></a>
<a class="sourceLine" id="cb4-6" title="6">   <span class="kw">generic</span> (</a>
<a class="sourceLine" id="cb4-7" title="7">          dataWidth<span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">4</span>;</a>
<a class="sourceLine" id="cb4-8" title="8">          addrWidth<span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb4-9" title="9">    );</a>
<a class="sourceLine" id="cb4-10" title="10">   <span class="kw">port</span> (</a>
<a class="sourceLine" id="cb4-11" title="11">          Endereco <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span> (addrWidth<span class="ot">-</span><span class="dv">1</span> <span class="ot">DOWNTO</span> <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb4-12" title="12">          Dado <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span> (dataWidth<span class="ot">-</span><span class="dv">1</span> <span class="ot">DOWNTO</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb4-13" title="13">    );</a>
<a class="sourceLine" id="cb4-14" title="14"><span class="kw">end entity;</span></a>
<a class="sourceLine" id="cb4-15" title="15"></a>
<a class="sourceLine" id="cb4-16" title="16"><span class="kw">architecture</span> <span class="kw">assincrona</span> <span class="kw">of</span> <span class="kw">memoriaROM</span> <span class="kw">is</span></a>
<a class="sourceLine" id="cb4-17" title="17"></a>
<a class="sourceLine" id="cb4-18" title="18">  <span class="ot">type</span> blocoMemoria <span class="kw">is</span> <span class="kw">array</span>(<span class="dv">0</span> <span class="ot">TO</span> <span class="dv">2</span><span class="ot">**</span>addrWidth <span class="ot">-</span> <span class="dv">1</span>) <span class="kw">of</span> <span class="dt">std_logic_vector</span>(dataWidth<span class="ot">-</span><span class="dv">1</span> <span class="ot">DOWNTO</span> <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb4-19" title="19"></a>
<a class="sourceLine" id="cb4-20" title="20">  <span class="kw">function</span> initMemory</a>
<a class="sourceLine" id="cb4-21" title="21">        <span class="kw">return</span> blocoMemoria <span class="kw">is</span> <span class="ot">variable</span> tmp <span class="ot">:</span> blocoMemoria <span class="ot">:=</span> (<span class="ot">others</span> <span class="ot">=&gt;</span> (<span class="ot">others</span> <span class="ot">=&gt;</span> <span class="bn">&#39;0&#39;</span>));</a>
<a class="sourceLine" id="cb4-22" title="22">  <span class="kw">begin</span></a>
<a class="sourceLine" id="cb4-23" title="23">      <span class="co">-- Palavra de Controle = SelMUX, Habilita_A, Reset_A, Operacao_ULA</span></a>
<a class="sourceLine" id="cb4-24" title="24">      <span class="co">-- Inicializa os endereços:</span></a>
<a class="sourceLine" id="cb4-25" title="25">        tmp(<span class="dv">0</span>)  <span class="ot">:=</span> <span class="st">&quot;1011&quot;</span>;   <span class="co">-- Desta posicao para baixo, é necessário acertar os valores</span></a>
<a class="sourceLine" id="cb4-26" title="26">        tmp(<span class="dv">1</span>)  <span class="ot">:=</span> <span class="st">&quot;0000&quot;</span>;</a>
<a class="sourceLine" id="cb4-27" title="27">        tmp(<span class="dv">2</span>)  <span class="ot">:=</span> <span class="st">&quot;0000&quot;</span>;</a>
<a class="sourceLine" id="cb4-28" title="28">        tmp(<span class="dv">3</span>)  <span class="ot">:=</span> <span class="st">&quot;0000&quot;</span>;</a>
<a class="sourceLine" id="cb4-29" title="29">        tmp(<span class="dv">4</span>)  <span class="ot">:=</span> <span class="st">&quot;0000&quot;</span>;</a>
<a class="sourceLine" id="cb4-30" title="30">        tmp(<span class="dv">5</span>)  <span class="ot">:=</span> <span class="st">&quot;0000&quot;</span>;</a>
<a class="sourceLine" id="cb4-31" title="31">        tmp(<span class="dv">6</span>)  <span class="ot">:=</span> <span class="st">&quot;0000&quot;</span>;</a>
<a class="sourceLine" id="cb4-32" title="32">        tmp(<span class="dv">7</span>)  <span class="ot">:=</span> <span class="st">&quot;0000&quot;</span>;</a>
<a class="sourceLine" id="cb4-33" title="33">        <span class="kw">return</span> tmp;</a>
<a class="sourceLine" id="cb4-34" title="34">    <span class="kw">end </span>initMemory;</a>
<a class="sourceLine" id="cb4-35" title="35"></a>
<a class="sourceLine" id="cb4-36" title="36">    <span class="ot">signal</span> memROM <span class="ot">:</span> blocoMemoria <span class="ot">:=</span> initMemory;</a>
<a class="sourceLine" id="cb4-37" title="37"></a>
<a class="sourceLine" id="cb4-38" title="38"><span class="kw">begin</span></a>
<a class="sourceLine" id="cb4-39" title="39">    Dado <span class="ot">&lt;=</span> memROM (to_integer(<span class="dt">unsigned</span>(Endereco)));</a>
<a class="sourceLine" id="cb4-40" title="40"><span class="kw">end architecture;</span></a></code></pre></div>
</div>
<!--- class_panel --->
<button class="accordion">
Resultado
</button>
<div class="panel">
<p>O resultado da compilação será o circuito, em RTL, mostrado no diagrama abaixo.</p>
<figure>
<img src="imagensCircuitos/Aula2_RTL.jpg" alt="RTL do Computador" style="width:600px;" /><figcaption><strong>RTL do Computador</strong></figcaption>
</figure>
<p>Para fazer a simulação, reagrupe os sinais de entrada e saída conforme o mostrado na figura abaixo.</p>
<p>Além disso, repare nos valores da entrada de dados, mostrados abaixo.</p>
<figure>
<img src="imagensCircuitos/Aula2_DetalheGruposSinais.jpg" alt="Reagrupamento dos Sinais de Entrada e Saída" style="width:600px;" /><figcaption><strong>Reagrupamento dos Sinais de Entrada e Saída</strong></figcaption>
</figure>
<p>Considerando o valor de X como sendo 3, o resultado da simulação está mostrado abaixo.</p>
<figure>
<img src="imagensCircuitos/Aula2_Simulacao.jpg" alt="Simulação da Equação 3X -4, com X = 3" style="width:600px;" /><figcaption><strong>Simulação da Equação 3X -4, com X = 3</strong></figcaption>
</figure>
</div>
<!--- class_panel --->
<br>
<div class="quiz" style="width:600px;">
<div class="row">
<div class="column" style="width:60px;">
<p><img src="imagensComponentes/Aviso.svg" style="width:30px;" /></p>
</div>
<div class="column" style="width:500px;">
<p>
Esta Atividade deverá ser entregue através do Blackboard!
</p>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="relatório-da-atividade">Relatório da Atividade</h2>
<button class="accordion">
Preencher e Enviar o Relatório (abaixo) Após a Conclusão da Atividade
</button>
<div class="panel">
<iframe src="https://docs.google.com/forms/d/e/1FAIpQLSfhFoHPveUMckjFcDNJ_knx3IZ9Aq1bvUN9aXbdlN12VIpf3A/viewform?embedded=true" width="640" height="400" frameborder="0" marginheight="0" marginwidth="0">
Carregando…
</iframe>
</div>
<!--- class_panel --->
<br>
<hr>
<p><br></p>
<h2 id="ferramenta-auxiliar-conversor-binário-para-decimal-com-ou-sem-sinal">Ferramenta Auxiliar: Conversor Binário para Decimal (com ou sem sinal)</h2>
<div style="width:600px;margin:10px auto;font-family:Courier New,Courier,monospace;">
<form>
<div style="width:50%;float:left;display:inline-block;">
<label for="entrada">Valor em Binário:</label>
<textarea id="entrada" cols="32" rows="1" title="Valor em binário a ser convertido" onkeyup="validaBinario(id)" style="resize:none;">
</textarea>
</div>
<div style="width:50%;float:left;display:inline-block;">
<label for="saida">Resultado da Conversão:</label>
<textarea id="saida" cols="32" rows="1" title="Valor convertido" style="resize:none;">
</textarea>
</div>
<input type="button" value="Converter" onclick="converteBinario(entrada);"/>    <input type="checkbox" id="tiposigned" style="vertical-align:middle;">Binário com Sinal</input>
</form>
</div>
<script type="text/javascript">
function converteBinario(nome) {
tipo = document.getElementById("tiposigned").checked;
binStr = nome.value;
if (binStr === "") {
document.getElementById("saida").value = "Faltou o valor de entrada.";
}else{
if (tipo){
document.getElementById("saida").value = converteSignedDecimal(binStr);
}else{
document.getElementById("saida").value = converteUnsignedDecimal(binStr);
}
}
}
</script>
<p><br> <a href="./Ferramentas.html" target="_blank">Outras Ferramentas</a> <br></p>
<hr />
<p><br></p>
<hr />
<hr />
<script type="text/javascript" src="./js/acordeon.js"></script>
<script src="./js/binario.js"></script>
<!-- FIM -->
</body>
</html>
